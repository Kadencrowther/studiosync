<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta name="description" content="" />
    <meta name="author" content="" />
    <title>Communication- Studio Sync</title>
    <!-- Favicon -->
    <link rel="icon" href="assets/ssdancer.svg" type="image/svg+xml">

    <!-- Core theme CSS (includes Bootstrap)-->
    <link href="css/styles.css" rel="stylesheet" />
    <!-- Font Awesome CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-...+..." crossorigin="anonymous" referrerpolicy="no-referrer" />
    <!-- Custom CSS for Modern Styling -->
    <style>
        :root {
            --primary-color: #3DCED7;
            --primary-hover: #36B8C0;
            --secondary-color: #3A506B;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #sidebar-wrapper {
            background-color: var(--primary-color);
            min-height: 100vh;
            box-shadow: 4px 0 15px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: sticky;
            top: 0;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar-heading {
            color: white;
            background-color: var(--primary-color);
            padding: 1.5rem 1rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: bold;
        }

        .list-group-item {
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s ease, padding 0.3s ease, transform 0.3s ease;
            padding: 1rem 1.5rem;
        }

        .list-group-item:hover,
        .list-group-item-action:focus {
            background-color: var(--primary-hover);
            color: white;
            transform: translateX(5px);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .navbar {
            background-color: #ffffff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1rem 1.5rem;
        }

        .navbar .navbar-nav .nav-link {
            color: #333;
            transition: color 0.3s ease;
        }

        .navbar .navbar-nav .nav-link:hover {
            color: var(--primary-color);
        }

        .container-fluid {
            background-color: #fff;
            color: #525f7f;
            padding: 2rem;
        }

        /* Modernized Dashboard Content */
        .dashboard-insights {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
        }

        .dashboard-insights .insight-box {
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            text-align: center;
        }

        .insight-box h3 {
            font-size: 1.2rem;
            color: #525f7f;
            margin-bottom: 0.5rem;
        }

        .insight-box p {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin: 0;
        }

        .progress-ring {
            margin-top: 20px;
        }

        /* Schedule Table */
        .schedule-table {
            margin-top: 2rem;
            width: 100%;
            border-collapse: collapse;
        }

        .schedule-table th,
        .schedule-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        .schedule-table th {
            background-color: var(--primary-color);
            color: white;
        }

        .schedule-table td {
            background-color: #f9f9f9;
        }

        /* New styles for the pie chart and layout */
        .dashboard-container {
            display: flex;
            gap: 1.5rem; /* Match the gap of dashboard-insights */
        }

        .pie-chart-container {
            flex: 0.8;
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: calc(100% - 3rem); /* Subtract padding to match KPI cards exactly */
            transition: box-shadow 0.3s ease;
        }

        .pie-chart-container:hover {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .chart-wrapper {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .capacity-input-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            margin-top: 0.5rem;
        }

        .capacity-input-container label {
            font-size: 0.8rem;
            margin-right: 0.5rem;
            color: #525f7f;
        }

        #capacityInput {
            width: 60px;
            padding: 0.3rem 0.5rem;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            font-size: 0.8rem;
            color: #525f7f;
            transition: all 0.3s ease;
            background-color: #f8f9fa;
        }

        #capacityInput:focus {
            outline: none;
            border-color: #3DCED7;
            box-shadow: 0 0 0 2px rgba(61, 206, 215, 0.1);
            background-color: #ffffff;
        }

        #capacityInput::-webkit-inner-spin-button,
        #capacityInput::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #capacityInput {
            -moz-appearance: textfield;
        }

        .kpi-container {
            flex: 2;
        }

        .dashboard-insights {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1.5rem;
            height: 100%;
        }

        .insight-box {
            background-color: #fff;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        /* Payment form styles */
        #payment-form {
            max-width: 500px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        #card-element {
            margin-bottom: 20px;
        }

        #submit-payment {
            background-color: #3DCED7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #submit-payment:hover {
            background-color: #36B8C0;
        }

        #submit-payment:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Subscription form styles */
        .subscription-form {
            max-width: 500px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .subscription-form input, .subscription-form select {
            width: 100%;
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .subscription-form button {
            background-color: #3DCED7;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .subscription-form button:hover {
            background-color: #36B8C0;
        }

        .navbar-nav .dropdown-menu {
            min-width: 250px;
            border: none;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-radius: 8px;
            padding: 0;
        }

        .navbar-nav .dropdown-item {
            padding: 12px 20px;
            color: #333;
            transition: background-color 0.3s ease;
        }

        .navbar-nav .dropdown-item:hover {
            background-color: #f8f9fa;
        }

        .navbar-nav .dropdown-divider {
            margin: 0;
            border-top-color: #e9ecef;
        }

        .navbar-nav .dropdown-header {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 600;
            color: #6c757d;
            background-color: #f8f9fa;
        }

        .navbar-nav .dropdown-item-text {
            padding: 12px 20px;
            color: #6c757d;
        }

        .fa-user-circle {
            font-size: 1.8em; /* Slightly smaller profile icon */
        }

        .nav-item {
            position: relative;
        }

        .nav-link {
            padding: 0.5rem 0.5rem;
        }

        .fa-bell {
            font-size: 1.2em;
            position: relative;
        }

        .notification-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 0.6em;
            background-color: #dc3545;
            color: white;
            border-radius: 50%;
            padding: 2px 5px;
            font-weight: bold;
            min-width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .notification-item {
            display: flex;
            align-items: center;
            padding: 12px 20px;
        }

        .notification-icon {
            margin-right: 15px;
            font-size: 1.2em;
            color: #3DCED7;
        }

        .notification-content {
            flex-grow: 1;
        }

        .notification-title {
            font-weight: 600;
            margin-bottom: 2px;
        }

        .notification-subtitle {
            font-size: 0.85em;
            color: #6c757d;
        }

        .navbar-nav .dropdown-toggle::after {
            display: none;
        }

        @media (max-width: 991.98px) {
            .navbar-brand-center {
                position: static;
                transform: none;
            }

            .navbar-nav {
                flex-direction: row;
            }

            .nav-item.dropdown {
                position: static;
            }

            .dropdown-menu {
                left: 0;
                right: 0;
                width: 100%;
            }
        }

        @media (max-width: 575.98px) {
            .navbar-brand-center {
                max-width: 200px;
                margin: 0 auto;
            }

            #studio-logo, #studio-name {
                max-width: 100%;
            }

            .navbar-nav {
                justify-content: center;
            }
        }

        /* Add styles for the page content wrapper */
        #page-content-wrapper {
            flex: 1;
            height: 100vh;
            overflow-y: auto;
        }

        /* Update the wrapper styles */
        #wrapper {
            display: flex;
            overflow: hidden;
            height: 100vh;
        }

        /* Sidebar overlay styles */
        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1045;
            transition: opacity 0.3s ease;
        }

        @media (max-width: 768px) {
            #sidebar-wrapper {
                margin-left: -250px;
                transition: margin 0.3s ease-out;
                position: fixed;
                z-index: 1050;
                height: 100vh;
            }

            .sidebar-overlay.show {
                display: block;
            }

            #wrapper.toggled #sidebar-wrapper {
                margin-left: 0;
            }
        }

        /* Wrapper transitions */
        #wrapper.toggled #sidebar-wrapper {
            margin-left: -250px;
        }

        #wrapper.toggled #page-content-wrapper {
            margin-left: 0;
        }

        /* Update the toggle button styles */
        #sidebarToggle {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
            color: white;
            transition: all 0.3s ease;
        }

        #sidebarToggle:hover {
            background-color: var(--primary-hover);
            border-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        /* Update other elements that use the primary color */
        .navbar .navbar-nav .nav-link:hover {
            color: var(--primary-color);
        }

        .insight-box p {
            color: var(--primary-color);
        }

        .schedule-table th {
            background-color: var(--primary-color);
        }

        /* Loading Overlay Styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease-out;
        }

        .loading-content {
            text-align: center;
        }

        .loading-text {
            margin-top: 20px;
        }

        .loading-text h2 {
            color: #ffffff;
            margin-bottom: 10px;
            transition: color 0.5s ease;
        }

        .loading-text p {
            color: #ffffff;
            font-size: 1.1em;
            transition: color 0.5s ease;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #ffffff;
            border-radius: 50%;
            margin: 0 auto;
            animation: spin 1s linear infinite;
            transition: border-top-color 0.5s ease;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-overlay.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        /* User Avatar Styles */
        .user-avatar {
            width: 38px;
            height: 38px;
            background: var(--primary-color);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            font-weight: 600;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }

        .user-avatar:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .initials {
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Profile Dropdown Styles */
        .dropdown-menu .dropdown-item-text#studioNameDisplay {
            padding: 0.3rem 1.5rem;
            margin: 0;
            color: #333333;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .dropdown-menu .dropdown-item-text#userRole {
            padding: 0.2rem 1.5rem;
            margin: 0;
            color: #666;
            font-size: 0.85rem;
            font-weight: 400;
        }

        /* User Profile Styles */
        .dropdown-menu {
            position: absolute;
            top: calc(100% + 0.75rem);
            right: 0;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 25px rgba(0,0,0,0.1);
            padding: 1rem 0;
            min-width: 280px;
            display: none;
            z-index: 1000;
            border: 1px solid rgba(0,0,0,0.08);
            position: fixed;
            margin-right: 1rem;
        }

        /* Responsive Styles */
        @media (max-width: 991.98px) {
            .dashboard-container {
                flex-direction: column;
                gap: 1.5rem;
            }

            .pie-chart-container {
                width: 100%;
                min-height: 300px;
            }

            .kpi-container {
                width: 100%;
            }

            .dashboard-insights {
                grid-template-columns: repeat(2, 1fr);
                gap: 1rem;
            }

            .insight-box {
                padding: 1rem;
            }

            .insight-box h3 {
                font-size: 1rem;
            }

            .insight-box p {
                font-size: 2rem;
            }

            .schedule-table {
                display: block;
                overflow-x: auto;
                white-space: nowrap;
                -webkit-overflow-scrolling: touch;
            }

            .schedule-table th,
            .schedule-table td {
                padding: 8px;
                font-size: 0.9rem;
            }
        }

        @media (max-width: 575.98px) {
            .dashboard-insights {
                grid-template-columns: 1fr;
            }

            .container-fluid {
                padding: 1rem;
            }

            h2 {
                font-size: 1.5rem;
            }

            .pie-chart-container {
                min-height: 250px;
            }

            .insight-box {
                margin-bottom: 0.5rem;
            }

            .schedule-table th,
            .schedule-table td {
                padding: 6px;
                font-size: 0.85rem;
            }

            #wrapper {
                min-height: 100vh;
                overflow-x: hidden;
                position: relative;
            }

            #sidebar-wrapper {
                margin-left: -250px;
                transition: margin 0.25s ease-out;
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 1050;
                width: 250px;
            }

            #wrapper.toggled #sidebar-wrapper {
                margin-left: 0;
            }

            #page-content-wrapper {
                min-width: 100vw;
                margin-left: 0;
                transition: margin 0.25s ease-out;
            }

            .sidebar-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 1045;
            }

            #wrapper.toggled .sidebar-overlay {
                display: block;
            }

            /* Adjust navbar for mobile */
            .navbar {
                padding: 0.5rem;
            }

            .navbar-brand-center {
                max-width: 150px;
            }

            #studio-logo {
                max-height: 80px;
            }

            #studio-name {
                font-size: 1.2rem;
            }

            #sidebarToggle {
                padding: 0.375rem 0.75rem;
                font-size: 0.9rem;
            }
        }

        /* Ensure content doesn't overflow on very small devices */
        @media (max-width: 360px) {
            .container-fluid {
                padding: 0.75rem;
            }

            .insight-box {
                padding: 0.75rem;
            }

            .insight-box h3 {
                font-size: 0.9rem;
            }

            .insight-box p {
                font-size: 1.75rem;
            }

            .navbar-brand-center {
                max-width: 120px;
            }

            #studio-name {
                font-size: 1rem;
            }
        }

        /* Update Calendar Specific Styles */
        .calendar-controls {
            background: linear-gradient(135deg, #EEF2FF 0%, #F8FAFC 100%);
            padding: 1.25rem;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(100, 116, 139, 0.12);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            margin-bottom: 2rem;
        }

        .current-month {
            font-size: 1.75rem;
            font-weight: 600;
            color: #4F46E5;
            min-width: 200px;
            text-align: center;
        }

        .calendar-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(100, 116, 139, 0.12);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.18);
            overflow: hidden;
        }

        .calendar-header {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            background: #EEF2FF;
            border-bottom: 1px solid rgba(99, 102, 241, 0.1);
        }

        .calendar-cell.header {
            padding: 1.25rem 1rem;
            text-align: center;
            font-weight: 600;
            color: #4F46E5;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
        }

        .calendar-body {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-auto-rows: minmax(140px, auto);
            gap: 1px;
            background: rgba(0, 0, 0, 0.05);
        }

        .calendar-day {
            background: white;
            padding: 0.75rem;
            min-height: 140px;
            position: relative;
            transition: all 0.3s ease;
        }

        .calendar-day:hover {
            background: #F8FAFC;
            transform: translateY(-1px);
        }

        .calendar-day.other-month {
            background: #f8f9fa;
        }

        .day-number {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            font-size: 0.9rem;
            color: #64748b;
            transition: all 0.3s ease;
        }

        .calendar-day.today {
            background: #F0F9FF;
        }

        .calendar-day.today .day-number {
            background: #38BDF8;
            color: white;
            font-weight: 600;
        }

        .class-event {
            padding: 0.5rem 0.75rem;
            margin: 0.35rem 0;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            color: #1E293B;
        }

        .class-event.ballet {
            background: #FCE7F3;
            border-left: 3px solid #EC4899;
        }

        .class-event.jazz {
            background: #FEF3C7;
            border-left: 3px solid #F59E0B;
        }

        .class-event.tap {
            background: #DBEAFE;
            border-left: 3px solid #3B82F6;
        }

        .class-event.contemporary {
            background: #F3E8FF;
            border-left: 3px solid #9333EA;
        }

        .class-event.hiphop {
            background: #ECFCCB;
            border-left: 3px solid #84CC16;
        }

        .class-event:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            filter: brightness(0.95);
        }

        /* Calendar View Controls */
        .calendar-view-controls .btn-group {
            background: white;
            padding: 4px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(100, 116, 139, 0.1);
        }

        .calendar-view-controls .btn {
            border: none;
            padding: 0.5rem 1.25rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: #6B7280;
            background: transparent;
            transition: all 0.2s ease;
            border-radius: 8px;
        }

        .calendar-view-controls .btn:hover {
            color: #4F46E5;
        }

        .calendar-view-controls .btn.active {
            background: #EEF2FF;
            color: #4F46E5;
            font-weight: 600;
        }

        /* Navigation Buttons */
        #prevMonth, #nextMonth {
            background: white;
            border: none;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4F46E5;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.1);
            transition: all 0.2s ease;
        }

        #prevMonth:hover, #nextMonth:hover {
            background: #EEF2FF;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.2);
        }

        /* Modal Updates */
        .modal-content {
            border: none;
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        /* Find the existing modal styles and update/add these styles */

        /* Update the modal header styles */
        .modal-header {
            background-color: var(--primary-color) !important; /* Add !important to ensure it overrides */
            color: white;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px 12px 0 0;
            padding: 1.5rem;
        }

        .modal-header .modal-title {
            color: white;
            font-weight: 600;
        }

        /* Update the close button color */
        .modal-header .btn-close {
            color: white;
            filter: brightness(0) invert(1);
        }

        .modal-body {
            padding: 1.5rem;
        }

        /* Responsive Updates */
        @media (max-width: 768px) {
            .calendar-controls {
                padding: 1rem;
            }

            .current-month {
                font-size: 1.4rem;
            }

            .calendar-day {
                padding: 1rem;
                border-radius: 12px;
                margin: 4px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            }

            .calendar-day::before {
                color: #64748b;
                font-size: 0.9rem;
                font-weight: 500;
            }

            .class-event {
                padding: 0.75rem;
                margin: 0.5rem 0;
            }
        }

        /* Add these new styles to your existing style section */
        
        .messaging-container {
            display: flex;
            height: calc(100vh - 70px);
            background-color: #f8fafc;
            gap: 1rem;
            padding: 1rem;
        }

        /* Channels/Groups Sidebar */
        .channels-sidebar {
            width: 300px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .search-container {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
        }

        .search-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            font-size: 0.875rem;
            transition: all 0.2s;
        }

        .search-input:focus {
            outline: none;
            border-color: #6366f1;
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            color: #1f2937;
        }

        .section-header h6 {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin: 0;
        }

        .btn-create {
            width: 28px;
            height: 28px;
            border-radius: 6px;
            background-color: #f3f4f6;
            color: #4b5563;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .btn-create:hover {
            background-color: #e5e7eb;
            color: #1f2937;
        }

        /* Chat Area */
        .chat-area {
            flex: 1;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
        }

        .chat-header {
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            background-color: white;
            border-radius: 12px 12px 0 0;
        }

        .chat-title-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        #currentChatName {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
        }

        .member-count {
            font-size: 0.9rem;
            color: #6c757d;
            background-color: #f8f9fa;
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            margin-right: 0.5rem;
            display: inline-block;
        }

        .btn-icon {
            padding: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #6c757d;
            transition: all 0.2s ease;
            border: none;
            background: transparent;
            cursor: pointer;
        }

        .btn-icon:hover {
            color: var(--primary-color);
            transform: translateY(-1px);
        }

        .btn-icon i {
            font-size: 1.2rem;
        }

        .chat-actions {
            margin-left: auto;
        }

        /* Media query for mobile screens */
        @media (max-width: 768px) {
            .chat-title-container {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .member-count {
                font-size: 0.75rem;
                padding: 0.2rem 0.5rem;
            }
        }

        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            background-color: #f8fafc;
        }

        .message-input-container {
            padding: 1rem;
            background-color: white;
            border-top: 1px solid #e5e7eb;
            border-radius: 0 0 12px 12px;
        }

        .input-wrapper {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background-color: #f9fafb;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 0.5rem;
        }

        .message-input {
            flex: 1;
            border: none;
            background: none;
            padding: 0.5rem;
            resize: none;
            min-height: 40px;
            font-size: 0.875rem;
        }

        .message-input:focus {
            outline: none;
        }

        /* Update existing styles */
        .groups-list, .dm-list {
            padding: 0.5rem;
        }

        .group-item, .dm-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #333;
            background-color: transparent;
        }

        .group-item:hover, .dm-item:hover {
            background-color: rgba(61, 206, 215, 0.1);
            transform: translateX(2px);
        }

        .group-item.active, .dm-item.active {
            background-color: rgba(61, 206, 215, 0.2);
            font-weight: 500;
        }

        .group-prefix {
            color: var(--primary-color);
            margin-right: 0.75rem;
            font-weight: 600;
        }

        .group-name, .dm-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Update section headers */
        .section-header {
            padding: 1rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .section-header h6 {
            margin: 0;
            color: #666;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-size: 0.85rem;
        }

        /* Update create button */
        .btn-create {
            width: 28px;
            height: 28px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            background-color: rgba(61, 206, 215, 0.1);
            color: var(--primary-color);
            transition: all 0.2s ease;
        }

        .btn-create:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-1px);
        }

        /* Update channels sidebar */
        .channels-sidebar {
            width: 280px;
            background-color: white;
            border-radius: 12px;
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        /* Add smooth transitions */
        .group-item, .dm-item {
            position: relative;
        }

        .group-item::after, .dm-item::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: 0;
            width: 0;
            height: 2px;
            background-color: var(--primary-color);
            transition: width 0.2s ease;
        }

        .group-item:hover::after, .dm-item:hover::after,
        .group-item.active::after, .dm-item.active::after {
            width: 100%;
        }

        /* Message styling */
        .message {
            display: flex;
            margin: 1rem 0;
            padding: 0 1rem;
        }

        .message-content {
            max-width: 70%;
            background-color: #f0f2f5;  /* Light gray for received messages */
            padding: 0.8rem 1rem;
            border-radius: 1rem;
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
        }

        .message-main {
            flex: 1;
        }

        .message-options {
            position: relative;
        }

        /* Update the message options button styles */
        .message-options-btn {
            background: none;
            border: none;
            padding: 0.25rem;
            color: #d1d5db; /* Lighter gray color */
            opacity: 1; /* Always visible */
            transition: color 0.2s ease;
            cursor: pointer;
            border-radius: 4px;
            backdrop-filter: blur(8px);
        }

        /* Remove the hover-only visibility */
        .message:hover .message-options-btn {
            opacity: 1; /* Remove this rule since button is always visible now */
        }

        /* Update hover state */
        .message-options-btn:hover {
            color: #9ca3af; /* Slightly darker on hover but still light */
            background-color: rgba(148, 163, 184, 0.1);
        }

        /* Ensure the icon itself is properly sized and colored */
        .message-options-btn i {
            font-size: 1rem;
            color: inherit;
        }

        .message-options-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            min-width: 120px;
            z-index: 100;
            display: none;
        }

        .message-options-dropdown.show {
            display: block;
        }

        .message-option {
            padding: 0.5rem 1rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #4b5563;
            transition: all 0.2s ease;
        }

        .message-option:hover {
            background-color: #f3f4f6;
        }

        .message-option i {
            font-size: 0.875rem;
            width: 16px;
        }

        .message-text {
            font-size: 1rem;
            color: #6b7280; /* Changed to a lighter gray */
            margin-bottom: 0.3rem;
            word-wrap: break-word;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.3rem;
            font-size: 0.75rem;
            color: #65676b;
        }

        .message-author {
            font-weight: 500;
        }

        .message-time {
            color: #8e8e8e;
        }

        /* Style for messages sent by the current user */
        .message.sent {
            justify-content: flex-end;
        }

        .message.sent .message-content {
            background-color: #0084ff;  /* Light blue for sent messages */
            color: white;
        }

        .message.sent .message-text {
            color: white;
        }

        .message.sent .message-header {
            color: rgba(255, 255, 255, 0.8);
        }

        .message.sent .message-time {
            color: rgba(255, 255, 255, 0.7);
        }

        /* Add this modal HTML after your other modals */
        .modal fade {
            display: none;
            position: fixed;
            z-index: 1;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) !important;
            margin: 0;
            width: 90%;
            max-width: 500px;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 500px;
        }

        .modal-header {
            background-color: #3DCED7;
            color: white;
        }

        .modal-title {
            font-weight: bold;
        }

        .close {
            color: white;
        }

        .close:hover,
        .close:focus {
            color: #000;
            text-decoration: none;
        }

        .members-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .member-item {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #eee;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .member-item:last-child {
            border-bottom: none;
        }

        .member-name {
            font-weight: 500;
            color: #333;
        }

        .member-type {
            font-size: 0.8rem;
            color: #666;
            background-color: #f0f2f5;
            padding: 0.25rem 0.5rem;
            border-radius: 1rem;
        }

        .dm-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            margin: 0.25rem 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            color: #333;
        }

        .dm-item:hover {
            background-color: rgba(61, 206, 215, 0.1);
            transform: translateX(2px);
        }

        .dm-item.active {
            background-color: rgba(61, 206, 215, 0.2);
            font-weight: 500;
        }

        .dm-name {
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Add these styles to handle the active state */
        .group-item.active, .dm-item.active {
            background-color: rgba(61, 206, 215, 0.2);
            font-weight: 500;
        }

        /* Style the Create Group/DM buttons */
        #createGroupBtn, #createDMBtn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        #createGroupBtn:hover, #createDMBtn:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
        }

        /* Style the Cancel buttons */
        .modal-footer .btn-secondary {
            background-color: #6B7280;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .modal-footer .btn-secondary:hover {
            background-color: #4B5563;
            transform: translateY(-1px);
        }

        .members-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .member-item {
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .member-item:last-child {
            border-bottom: none;
        }

        .member-avatar {
            width: 40px;
            height: 40px;
            background-color: var(--primary-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .member-details {
            flex: 1;
        }

        .member-name {
            font-weight: 500;
            color: #1f2937;
            margin-bottom: 0.25rem;
        }

        .member-role {
            font-size: 0.875rem;
            color: #6b7280;
        }

        .member-item {
            display: flex;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid #e5e7eb;
            gap: 1rem;
        }

        .member-controls {
            display: flex;
            gap: 0.5rem;
        }

        .member-controls .btn-icon {
            padding: 0.25rem;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .member-controls .btn-icon:hover {
            transform: scale(1.1);
        }

        .member-controls i {
            transition: all 0.2s ease;
        }

      
            .member-item {
                display: flex;
                align-items: center;
                padding: 1rem;
                border-bottom: 1px solid #e5e7eb;
                gap: 1rem;
            }

            .member-controls {
                display: flex;
                gap: 0.5rem;
            }

            .member-controls .btn-icon {
                padding: 0.25rem;
                font-size: 0.9rem;
                transition: all 0.2s ease;
            }

            .member-controls .btn-icon:hover {
                transform: scale(1.1);
            }

            .member-controls i {
                transition: all 0.2s ease;
            }

    </style>
    <!-- Stripe JS -->
    <script src="https://js.stripe.com/v3/"></script>
    <!-- Payarc JS -->
    <script>
        function loadPayarcScript(src) {
            var script = document.createElement('script');
            script.src = src;
            script.onerror = function() {
                if (src === 'https://js.payarc.com/v1/payarc.js') {
                    console.warn('CDN failed, falling back to local copy');
                    loadPayarcScript('/path/to/local/payarc.js');
                } else {
                    console.error('Failed to load Payarc library');
                }
            };
            document.head.appendChild(script);
        }
        loadPayarcScript('https://js.payarc.com/v1/payarc.js');
    </script>
</head>
<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-content">
            <div class="spinner"></div>
            <div class="loading-text">
                <h2>Loading</h2>
                <p id="loadingStatus">Loading studio branding...</p>
            </div>
        </div>
    </div>

    <div class="d-flex" id="wrapper">
        <!-- Sidebar-->
        <div class="border-end" id="sidebar-wrapper">
            <div class="sidebar-heading">
                <img src="assets/StudioSyncTransparent.svg" alt="Studio Sync Logo" style="width: 150px; height: auto;">
            </div>
            <div class="list-group list-group-flush">
                <a class="list-group-item list-group-item-action p-3" href="dashboard.html">
                    <i class="fas fa-tachometer-alt me-2"></i>Dashboard
                </a>
                <a class="list-group-item list-group-item-action p-3" href="class-calendar.html">
                    <i class="fas fa-calendar-alt me-2"></i>Class Calendar
                </a>
                <a class="list-group-item list-group-item-action p-3 d-flex justify-content-between align-items-center" data-bs-toggle="collapse" href="#classesDropdown" role="button" aria-expanded="false" aria-controls="classesDropdown">
                    <span><i class="fas fa-chalkboard-teacher me-2"></i>Classes</span>
                    <i class="fas fa-chevron-down"></i>
                </a>
                <div class="collapse" id="classesDropdown">
                    <a class="list-group-item list-group-item-action ps-5" href="allclasses.html">
                        <i class="fas fa-list me-2"></i>All Classes
                    </a>
                    <a class="list-group-item list-group-item-action ps-5" href="recreational.html">
                        <i class="fas fa-dumbbell me-2"></i>Recreational
                    </a>
                    <a class="list-group-item list-group-item-action ps-5" href="team.html">
                        <i class="fas fa-users me-2"></i>Team
                    </a>
                    <a class="list-group-item list-group-item-action ps-5" href="soloduettrio.html">
                        <i class="fas fa-user-friends me-2"></i>Solo/Duet/Trio
                    </a>
                </div>
                <a class="list-group-item list-group-item-action p-3" href="families.html">
                    <i class="fas fa-home me-2"></i>Families
                </a>
                <a class="list-group-item list-group-item-action p-3" href="students.html">
                    <i class="fas fa-user-graduate me-2"></i>Students
                </a>
                <a class="list-group-item list-group-item-action p-3" href="instructors.html">
                    <i class="fas fa-chalkboard-teacher me-2"></i>Instructors
                </a>
                <a class="list-group-item list-group-item-action p-3" href="costumes.html">
                    <i class="fas fa-tshirt me-2"></i>Costumes
                </a>
                <a class="list-group-item list-group-item-action p-3" href="communication.html">
                    <i class="fas fa-comments me-2"></i>Communication
                </a>
                <a class="list-group-item list-group-item-action p-3" href="charges-payments.html">
                    <i class="fas fa-dollar-sign me-2"></i>Charges/Payments
                </a>
                <a class="list-group-item list-group-item-action p-3" href="reports.html">
                    <i class="fas fa-chart-bar me-2"></i>Reports
                </a>
                <a class="list-group-item list-group-item-action p-3" href="settings.html">
                    <i class="fas fa-cog me-2"></i>Settings
                </a>
            </div>
        </div>

        <!-- Page content wrapper-->
        <div id="page-content-wrapper">
            <!-- Top navigation-->
            <nav class="navbar navbar-expand-lg navbar-light border-bottom">
                <div class="container-fluid">
                    <button class="btn btn-primary" id="sidebarToggle" style="width: 100px;" data-bs-toggle="tooltip" data-bs-placement="right" title="Toggle Menu" data-bs-trigger="hover focus">
                        <i class="fas fa-bars"></i>
                    </button>

                    <!-- Centered Logo -->
                    <div class="navbar-brand-center">
                        <img id="studio-logo" src="" alt="Studio Logo" style="max-height: 120px; max-width: 240px; display: none;">
                        <span id="studio-name" style="font-size: 1.5rem; font-weight: bold; color: #3DCED7;"></span>
                    </div>

                    <!-- Notifications and Profile Icons -->
                    <div class="navbar-nav ms-auto d-flex align-items-center">
                        <!-- Profile Icon Dropdown -->
                        <div class="nav-item dropdown">
                            <a class="nav-link" href="#" id="profileDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
                                <div class="user-avatar">
                                    <span class="initials"></span>
                                </div>
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="profileDropdown">
                                <li><h6 class="dropdown-header" id="userName" style="font-size: 1.2rem; font-weight: 700; color: #333333;">User Name</h6></li>
                                <li><p class="dropdown-item-text" id="userEmail" style="font-size: 0.95rem; font-weight: 400; color: #333333;">user@example.com</p></li>
                                <li><p class="dropdown-item-text" id="studioNameDisplay" style="font-size: 1.1rem; font-weight: 600; color: #333333;">Studio Name</p></li>
                                <li><p class="dropdown-item-text" id="userRole" style="font-size: 0.85rem; font-weight: 400; color: #333333;">Role</p></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="settings.html"><i class="fas fa-cog me-2"></i>Settings</a></li>
                                <li><a class="dropdown-item" href="account.html"><i class="fas fa-user-cog me-2"></i>Account</a></li>
                                <li><hr class="dropdown-divider"></li>
                                <li><a class="dropdown-item" href="#" id="logoutButton"><i class="fas fa-sign-out-alt me-2"></i>Logout</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </nav>

            <!-- Page content-->
            <div class="container-fluid p-0">
                <div class="messaging-container">
                    <!-- Channels/DMs Sidebar -->
                    <div class="channels-sidebar">
                        <!-- Search Bar -->
                        <div class="search-container">
                            <input type="text" class="search-input" placeholder="Search messages or users...">
                        </div>

                        <!-- Groups Section -->
                        <div class="groups-section">
                            <div class="section-header">
                                <h6>Groups</h6>
                                <button class="btn btn-sm btn-create" data-bs-toggle="modal" data-bs-target="#createGroupModal">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                            <div id="groupsList" class="groups-list">
                                <!-- Groups will be dynamically populated here -->
                            </div>
                        </div>

                        <!-- Add this after your groups section -->
                        <div class="dm-section">
                            <div class="section-header">
                                <h6>Direct Messages</h6>
                                <button class="btn btn-sm btn-create" data-bs-toggle="modal" data-bs-target="#createDMModal">
                                    <i class="fas fa-plus"></i>
                                </button>
                            </div>
                            <div id="dmList" class="dm-list">
                                <!-- DMs will be populated here -->
                            </div>
                        </div>
                    </div>

                    <!-- Chat Area -->
                    <div class="chat-area" id="chatArea">
                        <!-- Chat Header -->
                        <div class="chat-header">
                            <div class="chat-title-container">
                                <h5 id="currentChatName">Select a conversation</h5>
                                <div class="d-flex align-items-center">
                                    <span id="memberCount" class="member-count me-2"></span>
                                    <button class="btn btn-icon" title="Message Info" data-bs-toggle="tooltip" data-bs-placement="left">
                                        <i class="fas fa-ellipsis-v"></i>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Messages Container -->
                        <div class="messages-container" id="messagesContainer">
                            <!-- Messages will be dynamically populated here -->
                        </div>

                        <!-- Message Input -->
                        <div class="message-input-container">
                            <div class="input-wrapper">
                                <textarea class="message-input" id="messageInput" placeholder="Type a message..." disabled></textarea>
                                <button class="btn btn-icon" id="sendMessageBtn" title="Send Message" disabled>
                                    <i class="fas fa-paper-plane"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Bootstrap core JS-->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Core theme JS-->
    <script src="js/scripts.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const wrapper = document.getElementById('wrapper');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const overlay = document.querySelector('.sidebar-overlay');

            function toggleSidebar(e) {
                if (e) {
                    e.preventDefault();
                    e.stopPropagation();
                }
                
                wrapper.classList.toggle('toggled');
                
                if (window.innerWidth <= 768) {
                    if (wrapper.classList.contains('toggled')) {
                        overlay.classList.add('show');
                    } else {
                        overlay.classList.remove('show');
                    }
                }
            }
        });

        // Toggle button click handler
        sidebarToggle.addEventListener('click', toggleSidebar);

        // Overlay click handler
        overlay.addEventListener('click', toggleSidebar);

        // Handle window resize
        window.addEventListener('resize', function() {
            if (window.innerWidth > 768) {
                overlay.classList.remove('show');
            }
        });
    
    </script>

    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-storage-compat.js"></script>

    <script>
    // Initialize Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyDRSW3u6gJSs98Z2Mkp5DYSC__ibDXXHAE",
        authDomain: "studiosync-af73d.firebaseapp.com",
        projectId: "studiosync-af73d",
        storageBucket: "studiosync-af73d.appspot.com",
        messagingSenderId: "172555302276",
        appId: "1:172555302276:web:55b661f9849441e2de59d1",
        measurementId: "G-EK7EFQGMSG"
    };
    firebase.initializeApp(firebaseConfig);

    // Function to apply studio branding colors
    function applyStudioBranding(studioData) {
        console.log(' Applying studio branding colors:', {
            PrimaryColor: studioData.PrimaryColor,
            SecondaryColor: studioData.SecondaryColor
        });

        const primaryColor = studioData.PrimaryColor || '#3DCED7';
        const secondaryColor = studioData.SecondaryColor || '#3A506B';

        // Update CSS variables for the sidebar and related elements
        document.documentElement.style.setProperty('--primary-color', primaryColor);
        document.documentElement.style.setProperty('--primary-hover', adjustColor(primaryColor, -10));
        document.documentElement.style.setProperty('--secondary-color', secondaryColor);

        // Update loading overlay elements with branded colors
        const loadingTitle = document.querySelector('.loading-text h2');
        const loadingText = document.querySelector('.loading-text p');
        const spinner = document.querySelector('.spinner');

        if (loadingTitle) loadingTitle.style.color = primaryColor;
        if (loadingText) loadingText.style.color = secondaryColor;
        if (spinner) spinner.style.borderTopColor = primaryColor;
    }

    // Helper function to adjust color brightness
    function adjustColor(color, percent) {
        const num = parseInt(color.replace('#', ''), 16);
        const amt = Math.round(2.55 * percent);
        const R = (num >> 16) + amt;
        const G = (num >> 8 & 0x00FF) + amt;
        const B = (num & 0x0000FF) + amt;
        return '#' + (
            0x1000000 +
            (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
            (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
            (B < 255 ? (B < 1 ? 0 : B) : 255)
        ).toString(16).slice(1);
    }

    // Function to get current user data
    async function getCurrentUserData() {
        const loadingStatus = document.getElementById('loadingStatus');
        const loadingOverlay = document.getElementById('loadingOverlay');

        try {
            const user = await new Promise((resolve) => {
                firebase.auth().onAuthStateChanged((user) => {
                    if (user) {
                        loadingStatus.textContent = "Authenticating user...";
                        resolve(user);
                    } else {
                        console.log('No user signed in');
                        window.location.href = '/studiologin.html';
                    }
                });
            });

            const studioId = localStorage.getItem('currentStudioId');
            const studioData = JSON.parse(localStorage.getItem('currentStudioData'));
            const userDocId = localStorage.getItem('userDocId');

            loadingStatus.textContent = "Loading studio branding...";
            
            if (studioData) {
                applyStudioBranding(studioData);
            }

            loadingStatus.textContent = "Fetching user data...";

            try {
                const userDoc = await firebase.firestore()
                    .collection('Studios')
                    .doc(studioId)
                    .collection('Users')
                    .doc(userDocId)
                    .get();

                const instructorDoc = !userDoc.exists ? await firebase.firestore()
                    .collection('Studios')
                    .doc(studioId)
                    .collection('Instructors')
                    .doc(user.uid)
                    .get() : null;

                let userData;
                let collectionType;

                if (userDoc.exists) {
                    userData = userDoc.data();
                    collectionType = 'Users';
                } else if (instructorDoc?.exists) {
                    userData = instructorDoc.data();
                    collectionType = 'Instructors';
                }

                if (userData) {
                    loadingStatus.textContent = "Loading...";
                    
                    const fullName = `${userData.FirstName} ${userData.LastName}`;
                    document.getElementById('userName').textContent = fullName;
                    document.getElementById('userEmail').textContent = userData.Email;
                    
                    // Set studio name in profile dropdown
                    const studioNameElement = document.getElementById('studioNameDisplay');
                    if (studioNameElement && studioData) {
                        studioNameElement.textContent = studioData.StudioName || 'Studio Name';
                    }
                    
                    // Set user initials in avatar
                    const initials = `${userData.FirstName[0]}${userData.LastName[0]}`;
                    const initialsElement = document.querySelector('.initials');
                    if (initialsElement) {
                        initialsElement.textContent = initials;
                    }

                    const roleElement = document.getElementById('userRole');
                    if (userData.Role) {
                        roleElement.textContent = userData.Role;
                        roleElement.style.color = '#333333';
                        roleElement.style.fontWeight = '700';
                    } else {
                        roleElement.textContent = 'No Role Assigned';
                        roleElement.style.color = '#666';
                    }

                    if (studioData?.LogoUrl) {
                        await loadStudioLogo(studioData.LogoUrl, studioData.StudioName);
                    } else {
                        await loadStudioLogo(null, studioData?.StudioName);
                    }

                    // Hide loading overlay with fade effect
                    loadingOverlay.classList.add('fade-out');
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 500);
                }
            } catch (error) {
                console.error('Error getting user document:', error);
                loadingStatus.textContent = "Error loading. Please refresh...";
            }
            
            if (studioData) {
                applyStudioBranding(studioData);
                updateSidebarLinks(studioData);
                updatePageUrl(studioData.StudioName);
            }
        } catch (error) {
            console.error('Error:', error);
            loadingStatus.textContent = "Error loading. Please refresh...";
        }
    }

    // Function to load and display the studio logo
    function loadStudioLogo(logoUrl, studioName) {
        return new Promise((resolve) => {
            const logoElement = document.getElementById('studio-logo');
            const nameElement = document.getElementById('studio-name');
            
            if (logoUrl) {
                logoElement.onload = () => resolve();
                logoElement.src = logoUrl;
                logoElement.alt = studioName || 'Studio Logo';
                logoElement.style.display = 'block';
                nameElement.style.display = 'none';
            } else {
                logoElement.style.display = 'none';
                nameElement.textContent = studioName || 'Studio Sync';
                nameElement.style.display = 'block';
                resolve();
            }
        });
    }

    // Call the function when the page loads
    getCurrentUserData();

    // Logout functionality
    document.getElementById('logoutButton').addEventListener('click', function() {
        firebase.auth().signOut().then(() => {
            // Clear studio context from localStorage
            localStorage.removeItem('currentStudioId');
            localStorage.removeItem('currentStudioData');
            // Redirect to studio login
            window.location.href = '/studiologin.html';
        }).catch((error) => {
            console.error('Logout Error:', error);
        });
    });

    // Add this function after the firebase initialization
    function getStudioNameForUrl(studioName) {
        // Remove spaces and special characters, keep alphanumeric only
        return studioName.replace(/[^a-zA-Z0-9]/g, '');
    }

    function updateSidebarLinks(studioData) {
        if (studioData?.StudioName) {
            const studioNameParam = getStudioNameForUrl(studioData.StudioName);
            
            const sidebarLinks = document.querySelectorAll('#sidebar-wrapper .list-group-item');
            sidebarLinks.forEach(link => {
                const currentHref = link.getAttribute('href');
                if (currentHref && currentHref.endsWith('.html')) {
                    const newHref = currentHref.replace('.html', `?studio=${studioNameParam}`);
                    link.setAttribute('href', newHref);
                }
            });
        }
    }

    function updatePageUrl(studioName) {
        if (studioName) {
            const studioNameParam = getStudioNameForUrl(studioName);
            const currentUrl = new URL(window.location.href);
            
            // Only update if we're on a .html page and don't already have the studio parameter
            if (currentUrl.pathname.endsWith('.html') && !currentUrl.searchParams.has('studio')) {
                const newUrl = `${currentUrl.pathname.replace('.html', '')}?studio=${studioNameParam}`;
                window.history.replaceState({}, '', newUrl);
            }
        }
    }
    </script>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize calendar
        let currentDate = new Date();
        updateCalendar(currentDate);

        // Event listeners for navigation
        document.getElementById('prevMonth').addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() - 1);
            updateCalendar(currentDate);
        });

        document.getElementById('nextMonth').addEventListener('click', () => {
            currentDate.setMonth(currentDate.getMonth() + 1);
            updateCalendar(currentDate);
        });

        // Calendar view controls
        document.querySelectorAll('.calendar-view-controls .btn').forEach(button => {
            button.addEventListener('click', function() {
                document.querySelectorAll('.calendar-view-controls .btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                // Implement view change logic here
            });
        });
    });

    function updateCalendar(date) {
        const monthNames = ["January", "February", "March", "April", "May", "June",
            "July", "August", "September", "October", "November", "December"
        ];

        // Update month display
        document.getElementById('currentMonth').textContent = 
            `${monthNames[date.getMonth()]} ${date.getFullYear()}`;

        const firstDay = new Date(date.getFullYear(), date.getMonth(), 1);
        const lastDay = new Date(date.getFullYear(), date.getMonth() + 1, 0);
        const startingDay = firstDay.getDay();
        const totalDays = lastDay.getDate();

        const calendarBody = document.getElementById('calendarBody');
        calendarBody.innerHTML = '';

        let day = 1;
        const today = new Date();

        // Sample class types and their corresponding classes
        const classTypes = ['ballet', 'jazz', 'tap', 'contemporary', 'hiphop'];
        const classNames = {
            ballet: 'Ballet Class',
            jazz: 'Jazz Dance',
            tap: 'Tap Dance',
            contemporary: 'Contemporary',
            hiphop: 'Hip Hop'
        };

        // Create calendar grid
        for (let i = 0; i < 42; i++) {
            const cell = document.createElement('div');
            cell.className = 'calendar-day';
            cell.setAttribute('data-day', monthNames[date.getMonth()].substring(0, 3));

            if (i >= startingDay && day <= totalDays) {
                const dayNumber = document.createElement('div');
                dayNumber.className = 'day-number';
                dayNumber.textContent = day;

                if (date.getFullYear() === today.getFullYear() &&
                    date.getMonth() === today.getMonth() &&
                    day === today.getDate()) {
                    cell.classList.add('today');
                }

                cell.appendChild(dayNumber);

                // Add sample class events (replace with actual data)
                if (day % 3 === 0) {
                    const classType = classTypes[Math.floor(Math.random() * classTypes.length)];
                    const event = document.createElement('div');
                    event.className = `class-event ${classType}`;
                    event.textContent = classNames[classType];
                    event.addEventListener('click', () => showClassDetails(classNames[classType], classType));
                    cell.appendChild(event);
                }

                day++;
            } else {
                cell.classList.add('other-month');
            }

            calendarBody.appendChild(cell);
        }
    }

    function showClassDetails(className, classType) {
        const modal = new bootstrap.Modal(document.getElementById('classDetailsModal'));
        const modalBody = document.querySelector('#classDetailsModal .modal-body');
        
        modalBody.innerHTML = `
            <h6 class="${classType}">${className}</h6>
            <p><strong>Time:</strong> 4:00 PM - 5:30 PM</p>
            <p><strong>Instructor:</strong> Jane Doe</p>
            <p><strong>Room:</strong> Studio A</p>
            <p><strong>Enrolled:</strong> 12/15 students</p>
        `;
        
        modal.show();
    }
    </script>

    <!-- Create Group Modal -->
    <div class="modal fade" id="createGroupModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Create New Group</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="createGroupForm">
                        <!-- Add communication type selection -->
                        <div class="mb-3">
                            <label class="form-label">Communication Type</label>
                            <select class="form-select" id="communicationType">
                                <option value="two-way">Two-Way Communication</option>
                                <option value="one-way">One-Way Communication (Announcements)</option>
                            </select>
                            <small class="form-text text-muted">
                                One-way communication allows only the creator to send messages. Two-way allows all members to participate.
                            </small>
                        </div>

                        <!-- Existing form fields -->
                        <div class="mb-3">
                            <label class="form-label">Group Type</label>
                            <select class="form-select" id="groupType">
                                <option value="custom">Custom Group</option>
                                <option value="class">Class Group</option>
                                <option value="instructors">Instructors Group</option>
                                <option value="families">Families Group</option>
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Group Name</label>
                            <input type="text" class="form-control" id="groupName" required>
                        </div>

                        <div class="mb-3" id="memberSelection">
                            <label class="form-label">Select Members</label>
                            <div class="member-list" style="max-height: 200px; overflow-y: auto;">
                                <!-- Members will be dynamically populated -->
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="createGroupBtn">Create Group</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create DM Modal -->
    <div class="modal fade" id="createDMModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">New Direct Message</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <form id="createDMForm">
                        <!-- Add communication type selection -->
                        <div class="mb-3">
                            <label class="form-label">Communication Type</label>
                            <select class="form-select" id="dmCommunicationType">
                                <option value="two-way">Two-Way Communication</option>
                                <option value="one-way">One-Way Communication (Announcements)</option>
                            </select>
                            <small class="form-text text-muted">
                                One-way communication allows only you to send messages. Two-way allows both parties to participate.
                            </small>
                        </div>

                        <!-- Existing form fields -->
                        <div class="mb-3">
                            <label class="form-label">Member Type</label>
                            <select class="form-select" id="dmMemberType">
                                <option value="families">Families</option>
                                <option value="instructors">Instructors</option>
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Search</label>
                            <input type="text" class="form-control" id="dmSearchInput" placeholder="Search by name...">
                        </div>

                        <div class="mb-3">
                            <label class="form-label">Select Member</label>
                            <div class="member-list" style="max-height: 200px; overflow-y: auto;">
                                <!-- Members will be dynamically populated -->
                            </div>
                        </div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="createDMBtn">Start Conversation</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this script before the closing body tag -->
    <script>
    // Initialize Firestore references
    const db = firebase.firestore();
    let currentStudioId = localStorage.getItem('currentStudioId');

    // Function to load families for the studio
    async function loadFamilies() {
        const familiesList = [];
        try {
            const familiesSnapshot = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Families')
                .get();
            
            familiesSnapshot.forEach(doc => {
                familiesList.push({
                    id: doc.id,
                    ...doc.data()
                });
            });
            return familiesList;
        } catch (error) {
            console.error('Error loading families:', error);
            return [];
        }
    }

    // Function to load instructors
    async function loadInstructors() {
        const instructorsList = [];
        try {
            const instructorsSnapshot = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Instructors')
                .get();
            
            instructorsSnapshot.forEach(doc => {
                instructorsList.push({
                    id: doc.id,
                    ...doc.data()
                });
            });
            return instructorsList;
        } catch (error) {
            console.error('Error loading instructors:', error);
            return [];
        }
    }

    // Function to load classes
    async function loadClasses() {
        const classesList = [];
        try {
            const classesSnapshot = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Classes')
                .get();
            
            classesSnapshot.forEach(doc => {
                classesList.push({
                    id: doc.id,
                    ...doc.data()
                });
            });
            return classesList;
        } catch (error) {
            console.error('Error loading classes:', error);
            return [];
        }
    }

    // Function to create a new group
    async function createGroup(groupData) {
        try {
            console.log('=== Create Group Function Started ===');
            console.log('Group data:', groupData);
            
            // Make sure current user is included in members if not already
            const currentUserDocId = localStorage.getItem('userDocId');
            if (!groupData.members.includes(currentUserDocId)) {
                groupData.members.push(currentUserDocId);
            }
            
            // Validate required fields
            if (!groupData.name) throw new Error('Group name is required');
            if (!groupData.members || !Array.isArray(groupData.members)) {
                throw new Error('Group members must be an array');
            }
            if (!currentStudioId) throw new Error('Studio ID is missing');
            
            // Create the document with careful field mapping
            const docData = {
                Name: groupData.name,
                Members: groupData.members,
                Type: 'group',
                GroupType: groupData.type || 'custom',
                CommunicationType: groupData.communicationType || 'two-way',
                CreatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                CreatedBy: currentUserDocId
            };
            
            console.log('Document data to write:', docData);
            console.log('Studio ID:', currentStudioId);
            
            // Create the document reference with a generated ID
            const commRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication');
                
            const newGroupRef = commRef.doc();
            console.log('New group reference path:', newGroupRef.path);
            
            // Create the document with explicit set() operation
            await newGroupRef.set(docData);
            console.log('Group created successfully with ID:', newGroupRef.id);
            
            return newGroupRef;
        } catch (error) {
            console.error('=== Error in createGroup ===');
            console.error('Error details:', error);
            console.error('Studio ID:', currentStudioId);
            console.error('Current user doc ID:', localStorage.getItem('userDocId'));
            
            // Throw a more informative error
            throw new Error(`Could not create group: ${error.message}`);
        }
    }

    // Add this at the top with other global variables
    let isLoadingCommunications = false;

    // Add this function to determine the correct document ID to use for messages
    async function getMessageParticipantId(userType = null) {
        // If no userType provided, determine it from the current user's role
        if (!userType) {
            const userDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Users')
                .doc(localStorage.getItem('userDocId'))
                .get();
            
            if (userDoc.exists) {
                const userData = userDoc.data();
                const userRoles = Array.isArray(userData.Role) ? userData.Role : [userData.Role];
                
                if (userRoles.some(role => ['Family', 'Parent'].includes(role))) {
                    userType = 'family';
                } else {
                    userType = 'staff'; // Instructors, admins, etc.
                }
            }
        }
        
        // For families, get the family ID
        if (userType === 'family') {
            const familyId = localStorage.getItem('familyDocId');
            if (familyId) return familyId;
            
            // If family ID isn't stored yet, try to find it
            const userEmail = firebase.auth().currentUser.email;
            const familiesSnapshot = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Families')
                .where('Email', '==', userEmail)
                .limit(1)
                .get();
            
            if (!familiesSnapshot.empty) {
                const familyId = familiesSnapshot.docs[0].id;
                localStorage.setItem('familyDocId', familyId);
                return familyId;
            }
        }
        
        // Default to userDocId for staff/instructors
        return localStorage.getItem('userDocId');
    }

    // Simplified loadAllCommunications function
    async function loadAllCommunications() {
        if (isLoadingCommunications) {
            console.log('Already loading communications, skipping...');
            return;
        }

        try {
            isLoadingCommunications = true;
            console.log('=== Starting Communications Load ===');
            
            if (!currentUser) {
                currentUser = await waitForAuth();
            }
            
            if (!currentUser) {
                console.error('No user logged in');
                return;
            }

            // Get the appropriate participant ID (either user doc ID or family doc ID)
            const participantId = await getMessageParticipantId();
            if (!participantId) {
                console.error('Participant ID not found');
                return;
            }

            console.log('Loading communications for participant ID:', participantId);

            // Clear existing lists
            const groupsList = document.getElementById('groupsList');
            const dmList = document.getElementById('dmList');
            groupsList.innerHTML = '';
            dmList.innerHTML = '';

            // Get all communications in one query using the participant ID
            const communicationsRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .where('Members', 'array-contains', participantId);

            // Get groups and DMs
            const groupsSnapshot = await communicationsRef
                .where('Type', '==', 'group')
                .get();

            const dmsSnapshot = await communicationsRef
                .where('Type', '==', 'dm')
                .get();

            // Track unique IDs
            const processedIds = new Set();
            let groupCount = 0;
            let dmCount = 0;

            console.log('=== Processing Groups ===');
            groupsSnapshot.forEach(doc => {
                const chatId = doc.id;
                if (!processedIds.has(chatId)) {
                    processedIds.add(chatId);
                    const chatData = doc.data();
                    groupCount++;
                    
                    const groupElement = document.createElement('div');
                    groupElement.className = 'group-item';
                    groupElement.setAttribute('data-group-id', chatId);
                    groupElement.innerHTML = `
                        <span class="group-prefix">#</span>
                        <span class="group-name">${chatData.Name}</span>
                    `;
                    
                    groupElement.addEventListener('click', () => {
                        document.querySelectorAll('.group-item, .dm-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        groupElement.classList.add('active');
                        openGroupChat(chatId, chatData);
                    });
                    
                    groupsList.appendChild(groupElement);
                }
            });

            console.log('=== Processing DMs ===');
            dmsSnapshot.forEach(async (doc) => {
                const dmData = doc.data();
                const dmId = doc.id;
                
                // Skip if already processed
                if (processedIds.has(dmId)) return;
                processedIds.add(dmId);
                
                // Get the display name dynamically
                const displayName = await getDMDisplayName(dmData);
                
                const dmElement = document.createElement('div');
                dmElement.className = 'dm-item';
                dmElement.setAttribute('data-dm-id', dmId);
                dmElement.innerHTML = `<span class="dm-name">${displayName}</span>`;
                
                dmElement.addEventListener('click', () => {
                    document.querySelectorAll('.group-item, .dm-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    dmElement.classList.add('active');
                    openDMChat(dmId, dmData);
                });
                
                dmList.appendChild(dmElement);
            });

            console.log('=== Communications Load Summary ===');
            console.log(`Groups found and loaded: ${groupCount}`);
            console.log(`DMs found and loaded: ${dmCount}`);
            console.log('Total unique conversations:', processedIds.size);
            console.log('=== End Communications Load ===');

        } catch (error) {
            console.error('Error loading communications:', error);
            console.error('Error details:', error.message);
        } finally {
            isLoadingCommunications = false;
        }
    }

    // Single initialization point
    const initCommunications = (() => {
        let initialized = false;
        
        return async () => {
            if (initialized) return;
            initialized = true;
            
            try {
                await waitForAuth();
                if (currentUser) {
                    await loadAllCommunications();
                } else {
                    console.error('No user logged in after auth initialization');
                }
            } catch (error) {
                console.error('Error during initialization:', error);
                initialized = false;
            }
        };
    })();

    // Single event listener
    document.addEventListener('DOMContentLoaded', initCommunications, { once: true });

    // Enhanced createDM function to prevent duplicate conversations
    async function createDM(memberId, memberName, communicationType) {
        try {
            console.log('=== CreateDM Function Started ===');
            console.log('Parameters:', { memberId, memberName, communicationType });
            
            const currentUser = firebase.auth().currentUser;
            if (!currentUser) throw new Error('No user logged in');
            
            // Get current participant's document ID (user or family)
            const currentParticipantId = await getMessageParticipantId();
            if (!currentParticipantId) throw new Error('Participant ID not found');
            
            console.log('Current participant ID:', currentParticipantId);
            console.log('Target member ID:', memberId);

            // Create a unique conversation ID based on both participants
            // This ensures we can identify duplicate attempts
            const participantIds = [currentParticipantId, memberId].sort();
            const uniqueConversationId = `dm_${participantIds[0]}_${participantIds[1]}`;
            
            console.log('Checking for existing conversation with ID:', uniqueConversationId);

            // First check if we've created a DM with this exact unique ID
            const exactMatchRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(uniqueConversationId);
                
            const exactMatchDoc = await exactMatchRef.get();
            
            if (exactMatchDoc.exists) {
                console.log('Found exact match DM using unique ID');
                return {
                    exists: true,
                    id: exactMatchDoc.id,
                    data: exactMatchDoc.data()
                };
            }

            // As a fallback, check by querying Members array
            console.log('No exact match found, checking by member arrays');
            const existingDMsQuery = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .where('Type', '==', 'dm')
                .where('Members', 'array-contains', currentParticipantId)
                .get();
            
            // Track if we find an existing conversation
            let existingDM = null;
            
            console.log(`Found ${existingDMsQuery.size} DMs containing current participant`);
            
            existingDMsQuery.forEach(doc => {
                const dmData = doc.data();
                console.log(`Checking DM ${doc.id}:`, dmData.Members);
                
                if (dmData.Members.length === 2 && 
                    dmData.Members.includes(memberId) && 
                    dmData.Members.includes(currentParticipantId)) {
                    console.log(`Found matching DM: ${doc.id}`);
                    existingDM = {
                        id: doc.id,
                        ...dmData
                    };
                }
            });

            if (existingDM) {
                console.log('Using existing DM:', existingDM.id);
                return {
                    exists: true,
                    id: existingDM.id,
                    data: existingDM
                };
            }

            // If no existing DM, create a new one WITH the unique ID
            console.log('Creating new DM with unique ID:', uniqueConversationId);
            
            // Use the uniqueConversationId as the document ID
            await exactMatchRef.set({
                Type: 'dm',
                Members: [currentParticipantId, memberId],
                CreatedAt: firebase.firestore.FieldValue.serverTimestamp(),
                CommunicationType: communicationType,
                AllowedSenders: communicationType === 'one-way' ?
                    [currentParticipantId] : // Only creator can send in one-way
                    [currentParticipantId, memberId], // Both can send in two-way
                UniqueId: uniqueConversationId // Store this for good measure
            });

            return {
                exists: false,
                id: uniqueConversationId
            };
        } catch (error) {
            console.error('Error creating DM:', error);
            throw error;
        }
    }

    // Update the event listener for create DM button
    document.getElementById('createDMBtn').addEventListener('click', async function() {
        const selectedMember = document.querySelector('input[name="dmMember"]:checked');
        const communicationType = document.getElementById('dmCommunicationType').value;
        
        if (!selectedMember) {
            alert('Please select a member to message');
            return;
        }

        try {
            const memberId = selectedMember.value;
            const memberType = document.getElementById('dmMemberType').value;
            
            // Get member details
            let memberDoc;
            let userDocId = memberId; // Default to the selected ID (for families)
            
            if (memberType === 'families') {
                memberDoc = await db.collection('Studios')
                    .doc(currentStudioId)
                    .collection('Families')
                    .doc(memberId)
                    .get();
            } else {
                // For instructors, get their document first
                memberDoc = await db.collection('Studios')
                    .doc(currentStudioId)
                    .collection('Instructors')
                    .doc(memberId)
                    .get();
                
                if (memberDoc.exists) {
                    // Look up the instructor's User document ID
                    const instructorData = memberDoc.data();
                    const userQuery = await db.collection('Studios')
                        .doc(currentStudioId)
                        .collection('Users')
                        .where('Email', '==', instructorData.Email)
                        .limit(1)
                        .get();
                    
                    if (!userQuery.empty) {
                        // Use the User document ID instead of Instructor ID
                        userDocId = userQuery.docs[0].id;
                        console.log(`Found User doc ID for instructor: ${userDocId}`);
                    } else {
                        console.warn('No matching User document found for instructor');
                    }
                }
            }

            if (!memberDoc.exists) {
                throw new Error('Selected member not found');
            }

            const memberData = memberDoc.data();
            const memberName = `${memberData.FirstName} ${memberData.LastName}`;
            
            // Create the DM or get existing one
            const dmResult = await createDM(userDocId, memberName, communicationType);

            // Close modal regardless of whether DM is new or existing
            const modal = bootstrap.Modal.getInstance(document.getElementById('createDMModal'));
            modal.hide();
            document.getElementById('createDMForm').reset();

            if (dmResult.exists) {
                // Show notification for existing DM
                showExistingDMNotification(memberName, dmResult.id, dmResult.data);
            } else {
                // Add the new DM to the UI
                const dmList = document.getElementById('dmList');
                const dmElement = document.createElement('div');
                dmElement.className = 'dm-item';
                dmElement.setAttribute('data-dm-id', dmResult.id);
                dmElement.innerHTML = `<span class="dm-name">${memberName}</span>`;
                
                // Add click handler
                dmElement.addEventListener('click', () => {
                    document.querySelectorAll('.group-item, .dm-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    dmElement.classList.add('active');
                    openDMChat(dmResult.id, {
                        Type: 'dm',
                        Members: [localStorage.getItem('userDocId'), userDocId],
                        CommunicationType: communicationType
                    });
                });
                
                dmList.appendChild(dmElement);

                // Automatically open the new DM chat
                dmElement.click();
            }
        } catch (error) {
            console.error('Error creating DM:', error);
            alert('Error creating conversation: ' + error.message);
        }
    });

    // Global variable to track modal state
    let existingDMNotificationShowing = false;

    // Function to show notification for existing DM
    function showExistingDMNotification(memberName, dmId, dmData) {
        // Check if we're already showing a notification
        if (existingDMNotificationShowing) {
            console.log('Preventing duplicate modal - one is already showing');
            return;
        }
        
        // Set flag to indicate a modal is showing
        existingDMNotificationShowing = true;
        
        // Remove any existing alert modals
        const existingAlerts = document.querySelectorAll('.modal#existingDMAlert');
        existingAlerts.forEach(alert => {
            if (alert && alert.parentNode) {
                document.body.removeChild(alert);
            }
        });

        // Create a new modal
        const alertDiv = document.createElement('div');
        alertDiv.className = 'modal fade';
        alertDiv.id = 'existingDMAlert';
        alertDiv.innerHTML = `
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Existing Conversation</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>A direct message with ${memberName} already exists.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-primary" id="existingDMOkBtn" data-bs-dismiss="modal">OK</button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.appendChild(alertDiv);
        
        // Create and show modal
        const modal = new bootstrap.Modal(alertDiv);
        modal.show();
        
        // Function to handle cleanup after modal is hidden
        const cleanupModal = function() {
            console.log('Modal hidden event triggered');
            
            // Reset flag
            existingDMNotificationShowing = false;
            
            // Remove the modal from DOM
            if (alertDiv && alertDiv.parentNode) {
                document.body.removeChild(alertDiv);
            }
            
            // Open the existing DM
            const existingDmElement = document.querySelector(`[data-dm-id="${dmId}"]`);
            if (existingDmElement) {
                existingDmElement.click();
            } else {
                // If the DM isn't in the list yet, add it
                const dmList = document.getElementById('dmList');
                const dmElement = document.createElement('div');
                dmElement.className = 'dm-item';
                dmElement.setAttribute('data-dm-id', dmId);
                
                // Get the display name
                getDMDisplayName(dmData).then(displayName => {
                    dmElement.innerHTML = `<span class="dm-name">${displayName}</span>`;
                }).catch(error => {
                    console.error('Error getting DM display name:', error);
                    dmElement.innerHTML = `<span class="dm-name">${memberName}</span>`;
                });
                
                // Add click handler
                dmElement.addEventListener('click', () => {
                    document.querySelectorAll('.group-item, .dm-item').forEach(item => {
                        item.classList.remove('active');
                    });
                    dmElement.classList.add('active');
                    openDMChat(dmId, dmData);
                });
                
                dmList.appendChild(dmElement);
                
                // Click the element to open the chat
                dmElement.click();
            }
            
            // Remove the event listener to prevent memory leaks
            alertDiv.removeEventListener('hidden.bs.modal', cleanupModal);
        };
        
        // Attach hidden event handler
        alertDiv.addEventListener('hidden.bs.modal', cleanupModal);
        
        // Also handle button click explicitly
        document.getElementById('existingDMOkBtn').addEventListener('click', function() {
            // This is a backup in case the hidden.bs.modal event doesn't fire properly
            if (existingDMNotificationShowing) {
                cleanupModal();
                modal.hide();
            }
        }, { once: true });
    }

    // Event listener for group type selection
    document.getElementById('groupType').addEventListener('change', async function(e) {
        const memberSelection = document.getElementById('memberSelection');
        const memberList = memberSelection.querySelector('.member-list');
        memberList.innerHTML = '';

        switch(e.target.value) {
            case 'class':
                const classes = await loadClasses();
                classes.forEach(classItem => {
                    memberList.innerHTML += `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="${classItem.id}" id="class_${classItem.id}">
                            <label class="form-check-label" for="class_${classItem.id}">
                                ${classItem.ClassName}
                            </label>
                        </div>
                    `;
                });
                break;
            case 'instructors':
                const instructors = await loadInstructors();
                instructors.forEach(instructor => {
                    memberList.innerHTML += `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="${instructor.id}" id="instructor_${instructor.id}">
                            <label class="form-check-label" for="instructor_${instructor.id}">
                                ${instructor.FirstName} ${instructor.LastName}
                            </label>
                        </div>
                    `;
                });
                break;
            case 'families':
                const families = await loadFamilies();
                families.forEach(family => {
                    memberList.innerHTML += `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="${family.id}" id="family_${family.id}">
                            <label class="form-check-label" for="family_${family.id}">
                                ${family.FirstName} ${family.LastName}
                            </label>
                        </div>
                    `;
                });
                break;
            case 'custom':
                // Load all possible members (families, instructors)
                const allFamilies = await loadFamilies();
                const allInstructors = await loadInstructors();
                
                memberList.innerHTML = '<h6>Families</h6>';
                allFamilies.forEach(family => {
                    memberList.innerHTML += `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="family_${family.id}" id="custom_family_${family.id}">
                            <label class="form-check-label" for="custom_family_${family.id}">
                                ${family.FirstName} ${family.LastName}
                            </label>
                        </div>
                    `;
                });

                memberList.innerHTML += '<h6 class="mt-3">Instructors</h6>';
                allInstructors.forEach(instructor => {
                    memberList.innerHTML += `
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" value="instructor_${instructor.id}" id="custom_instructor_${instructor.id}">
                            <label class="form-check-label" for="custom_instructor_${instructor.id}">
                                ${instructor.FirstName} ${instructor.LastName}
                            </label>
                        </div>
                    `;
                });
                break;
        }
    });

    // Event listener for create group button
    document.getElementById('createGroupBtn').addEventListener('click', async function() {
        const groupName = document.getElementById('groupName').value;
        const groupType = document.getElementById('groupType').value;
        const communicationType = document.getElementById('communicationType').value;
        const selectedMembers = Array.from(document.querySelectorAll('.member-list input:checked'))
            .map(input => input.value);

        if (!groupName || selectedMembers.length === 0) {
            alert('Please enter a group name and select at least one member');
            return;
        }

        try {
            // Process members based on group type
            let processedMembers = [];
            
            switch(groupType) {
                case 'instructors':
                    // For instructors, get their User document IDs
                    processedMembers = await Promise.all(selectedMembers.map(async (instructorId) => {
                        const instructorDoc = await db.collection('Studios')
                            .doc(currentStudioId)
                            .collection('Instructors')
                            .doc(instructorId)
                            .get();
                            
                        if (instructorDoc.exists) {
                            const instructorData = instructorDoc.data();
                            // Look up the instructor's User document ID by email
                            const userQuery = await db.collection('Studios')
                                .doc(currentStudioId)
                                .collection('Users')
                                .where('Email', '==', instructorData.Email)
                                .limit(1)
                                .get();
                                
                            if (!userQuery.empty) {
                                return userQuery.docs[0].id;
                            }
                        }
                        return null;
                    }));
                    // Filter out any null values
                    processedMembers = processedMembers.filter(id => id !== null);
                    break;
                    
                case 'families':
                    // For families, use their Family document IDs directly
                    processedMembers = selectedMembers;
                    break;
                    
                case 'class':
                    // For classes, get all students in the class and their family IDs
                    const familyIds = new Set();
                    
                    try {
                        console.log('Processing class group - getting classes:', selectedMembers);
                        
                        for (const classId of selectedMembers) {
                            try {
                                // Get the class document directly
                                console.log(`Fetching class: ${classId}`);
                                const classDoc = await db.collection('Studios')
                                    .doc(currentStudioId)
                                    .collection('Classes')
                                    .doc(classId)
                                    .get();
                                
                                if (classDoc.exists) {
                                    const classData = classDoc.data();
                                    // Get the Students array directly from the class document
                                    const studentIds = classData.Students || [];
                                    console.log(`Found ${studentIds.length} students for class ${classId}`);
                                    
                                    // Process each student ID
                                    for (const studentId of studentIds) {
                                        try {
                                            console.log(`Getting student: ${studentId}`);
                                            const studentDoc = await db.collection('Studios')
                                                .doc(currentStudioId)
                                                .collection('Students')
                                                .doc(studentId)
                                                .get();
                                            
                                            if (studentDoc.exists) {
                                                const studentData = studentDoc.data();
                                                if (studentData.FamilyId) {
                                                    console.log(`Adding family ID: ${studentData.FamilyId}`);
                                                    familyIds.add(studentData.FamilyId);
                                                } else {
                                                    console.log(`Student ${studentId} has no family ID`);
                                                }
                                            } else {
                                                console.log(`Student ${studentId} does not exist`);
                                            }
                                        } catch (studentError) {
                                            console.error(`Error processing student ${studentId}: ${studentError.message}`);
                                        }
                                    }
                                } else {
                                    console.log(`Class ${classId} does not exist`);
                                }
                            } catch (classError) {
                                console.error(`Error processing class ${classId}: ${classError.message}`);
                            }
                        }
                        
                        processedMembers = Array.from(familyIds);
                        console.log(`Total family IDs collected: ${processedMembers.length}`);
                        
                        // If no families found, use a simple approach - add group creator only
                        if (processedMembers.length === 0) {
                            console.log('No families found for the class, adding only group creator');
                            // The group creator will be added separately after this switch
                        }
                        
                    } catch (classGroupError) {
                        console.error('Error in class group processing:', classGroupError);
                        // Continue with empty members list - the creator will be added later
                        processedMembers = [];
                    }
                    break;
                    
                case 'custom':
                    // For custom groups, handle both instructors and families
                    processedMembers = await Promise.all(selectedMembers.map(async (memberId) => {
                        // Check if this is an instructor or family
                        if (memberId.startsWith('instructor_')) {
                            const instructorId = memberId.replace('instructor_', '');
                            const instructorDoc = await db.collection('Studios')
                                .doc(currentStudioId)
                                .collection('Instructors')
                                .doc(instructorId)
                                .get();
                                
                            if (instructorDoc.exists) {
                                const instructorData = instructorDoc.data();
                                // Look up User document by email
                                const userQuery = await db.collection('Studios')
                                    .doc(currentStudioId)
                                    .collection('Users')
                                    .where('Email', '==', instructorData.Email)
                                    .limit(1)
                                    .get();
                                    
                                if (!userQuery.empty) {
                                    return userQuery.docs[0].id;
                                }
                            }
                            return null;
                        } else if (memberId.startsWith('family_')) {
                            // For families, just return the ID portion
                            return memberId.replace('family_', '');
                        }
                        return null;
                    }));
                    // Filter out any null values
                    processedMembers = processedMembers.filter(id => id !== null);
                    break;
            }
            
            // Create the group with processed members
            const groupRef = await createGroup({
                name: groupName,
                type: groupType,
                members: processedMembers,
                communicationType: communicationType
            });
            
            // Rest of your existing code for adding the group to UI
            const groupsList = document.getElementById('groupsList');
            const groupElement = document.createElement('div');
            groupElement.className = 'group-item';
            groupElement.setAttribute('data-group-id', groupRef.id);
            groupElement.innerHTML = `
                <span class="group-prefix">#</span>
                <span class="group-name">${groupName}</span>
            `;
            
            groupElement.addEventListener('click', () => {
                document.querySelectorAll('.group-item, .dm-item').forEach(item => {
                    item.classList.remove('active');
                });
                groupElement.classList.add('active');
                openGroupChat(groupRef.id, {
                    Name: groupName,
                    Type: 'group',
                    GroupType: groupType,
                    Members: [...processedMembers, localStorage.getItem('userDocId')],
                    CommunicationType: communicationType
                });
            });
            
            groupsList.appendChild(groupElement);
            
            // Close modal and reset form
            const modal = bootstrap.Modal.getInstance(document.getElementById('createGroupModal'));
            modal.hide();
            document.getElementById('createGroupForm').reset();
            
            // Automatically open the new group chat
            groupElement.click();
            
        } catch (error) {
            console.error('Error creating group:', error);
            alert('Error creating group: ' + error.message);
        }
    });

    // Load initial groups when page loads
    document.addEventListener('DOMContentLoaded', function() {
        loadGroups();
    });
    </script>

    <script>
    let currentChatId = null;
    let currentChatType = null;

    // Update the setupMessageListener function
    function setupMessageListener(chatId) {
        if (window.currentMessageListener) {
            window.currentMessageListener();
        }

        // Clear messages container before setting up new listener
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';

        console.log('Setting up message listener for:', chatId);
        
        window.currentMessageListener = db.collection('Studios')
            .doc(currentStudioId)
            .collection('Communication')
            .doc(chatId)
            .collection('Messages')
            .orderBy('Timestamp', 'asc')
            .onSnapshot((snapshot) => {
                // Only clear if this is the initial load
                if (snapshot.docChanges().some(change => change.type === 'added' && !change.doc.metadata.hasPendingWrites)) {
                    messagesContainer.innerHTML = '';
                }
                
                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const messageData = {
                            ...change.doc.data(),
                            id: change.doc.id // Add the document ID to the message data
                        };
                        console.log('New message added:', messageData);
                        displayMessage(messageData);
                    }
                });
            }, (error) => {
                console.error('Error in message listener:', error);
            });
    }

    // Update the openGroupChat function
    async function openGroupChat(groupId, groupData) {
        console.log('=== Opening Group Chat ===');
        console.log('Group ID:', groupId);
        console.log('Group Data:', groupData);
        
        currentChatId = groupId;
        currentChatType = 'group';
        
        // Update UI
        document.getElementById('currentChatName').textContent = `#${groupData.Name}`;
        document.getElementById('messageInput').disabled = false;
        document.getElementById('sendMessageBtn').disabled = false;
        
        // Clear messages container before loading new messages
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';
        
        try {
            // Get the chat document to get latest member count
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(groupId)
                .get();

            if (chatDoc.exists) {
                const chatData = chatDoc.data();
                
                // Get the user document ID for permission check
                const userDocId = localStorage.getItem('userDocId');
                if (!userDocId) {
                    throw new Error('User document ID not found in localStorage');
                }
                
                // Check if user is allowed to view this group
                if (!chatData.Members.includes(userDocId)) {
                    throw new Error('You do not have permission to view this group');
                }
                
                const memberCount = chatData.Members?.length || 0;
                // Update member count display
                document.getElementById('memberCount').textContent = `${memberCount} members`;
                document.getElementById('memberCount').style.display = 'inline-block';
            }

            // Set up real-time listener
            setupMessageListener(groupId);
            
        } catch (error) {
            console.error('Error in openGroupChat:', error);
            messagesContainer.innerHTML = `
                <div class="text-center text-danger p-4">
                    Error: ${error.message}
                </div>
            `;
        }
    }

    // Update the openDMChat function
    async function openDMChat(dmId, dmData) {
        console.log('=== Opening DM Chat ===');
        console.log('DM ID:', dmId);
        console.log('DM Data:', dmData);
        currentChatId = dmId;
        currentChatType = 'dm';
        
        // Get display name dynamically
        const displayName = await getDMDisplayName(dmData);
        
        // Update UI with the dynamic name
        document.getElementById('currentChatName').textContent = displayName;
        document.getElementById('messageInput').disabled = false;
        document.getElementById('sendMessageBtn').disabled = false;
        
        // Clear messages container before loading new messages
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';
        
        try {
            // Get the chat document to check permissions
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(dmId)
                .get();

            if (!chatDoc.exists) {
                throw new Error('Chat not found');
            }

            const chatData = chatDoc.data();
            
            // Get the user document ID from localStorage for permission check
            const userDocId = localStorage.getItem('userDocId');
            if (!userDocId) {
                throw new Error('User document ID not found in localStorage');
            }
            
            // Check if user is allowed to view messages using userDocId
            if (!chatData.Members.includes(userDocId)) {
                throw new Error('You do not have permission to view this chat');
            }

            // Set up real-time listener for messages
            setupMessageListener(dmId);
            
            // Update member count for DMs - always 2 for direct messages
            document.getElementById('memberCount').textContent = '2 members';
            document.getElementById('memberCount').style.display = 'inline-block';
            
        } catch (error) {
            console.error('Error opening DM chat:', error);
            messagesContainer.innerHTML = `
                <div class="text-center text-danger p-4">
                    Error: ${error.message}
                </div>
            `;
        }
    }

    // Add this function to handle role checking
    async function checkUserPermissions() {
        try {
            console.log('Checking user permissions...');
            const userDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Users')
                .doc(localStorage.getItem('userDocId'))
                .get();

            if (!userDoc.exists) {
                console.error('User document not found');
                return false;
            }

            const userData = userDoc.data();
            console.log('User data:', userData);
            console.log('Raw user role:', userData.Role);

            // Handle both string and array cases
            const userRoles = Array.isArray(userData.Role) ? userData.Role : [userData.Role];
            console.log('Processed user roles:', userRoles);

            const hasAdminAccess = userRoles.some(role => ['Owner', 'Director', 'Admin'].includes(role));
            console.log('Has admin access:', hasAdminAccess);

            return hasAdminAccess;
        } catch (error) {
            console.error('Error checking permissions:', error);
            return false;
        }
    }

    // Update the loadMessages function
    async function loadMessages(chatId) {
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';
        
        try {
            console.log('Loading messages for chat:', chatId);
            const hasPermission = await checkUserPermissions();
            console.log('User has admin permission:', hasPermission);

            if (!hasPermission) {
                console.log('User is not admin, checking chat membership...');
                const chatDoc = await db.collection('Studios')
                    .doc(currentStudioId)
                    .collection('Communication')
                    .doc(chatId)
                    .get();

                if (!chatDoc.exists) {
                    console.error('Chat not found');
                    throw new Error('Chat not found');
                }

                const isMember = chatDoc.data().Members.includes(firebase.auth().currentUser.uid);
                console.log('User is chat member:', isMember);

                if (!isMember) {
                    throw new Error('You do not have permission to access this chat');
                }
            }

            console.log('Loading messages...');
            const messagesRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(chatId)
                .collection('Messages');
            
            const messagesSnapshot = await messagesRef.get();
            
            console.log('Messages loaded:', messagesSnapshot.size);
            
            messagesSnapshot.forEach(doc => {
                const messageData = {
                    ...doc.data(),
                    id: doc.id // Add the document ID to the message data
                };
                displayMessage(messageData);
            });
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

        } catch (error) {
            console.error('Error in loadMessages:', error);
            const errorMessage = error.code === 'permission-denied' 
                ? 'You do not have permission to access these messages. Please verify your chat membership.'
                : `Error loading messages: ${error.message}`;
            alert(errorMessage);
        }
    }

    // Function to display a message
    function displayMessage(messageData) {
        console.log('Displaying message:', messageData);
        const messagesContainer = document.getElementById('messagesContainer');
        const messageElement = document.createElement('div');
        
        // Get the user document ID for checking if message is from current user
        const userDocId = localStorage.getItem('userDocId');
        
        // Check if message is sent by current user
        const isSentByMe = messageData.SenderId === userDocId;
        messageElement.className = `message ${isSentByMe ? 'sent' : ''}`;
        
        const timestamp = messageData.Timestamp?.toDate() || new Date();
        const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        messageElement.innerHTML = `
            <div class="message-content">
                <div class="message-main">
                    <div class="message-text">${messageData.Content}</div>
                    <div class="message-header">
                        <span class="message-author">${messageData.SenderName}</span>
                        <span class="message-time">${timeString}</span>
                    </div>
                </div>
                <div class="message-options">
                    <button class="message-options-btn" aria-label="Message options">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                    <div class="message-options-dropdown">
                        <div class="message-option edit-message">
                            <i class="fas fa-edit"></i>
                            Edit
                        </div>
                        <div class="message-option delete-message">
                            <i class="fas fa-trash"></i>
                            Delete
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        messagesContainer.appendChild(messageElement);

        // Scroll to bottom after adding new message
        messagesContainer.scrollTop = messagesContainer.scrollHeight;

        // Add click handler for options button
        const optionsBtn = messageElement.querySelector('.message-options-btn');
        const optionsDropdown = messageElement.querySelector('.message-options-dropdown');
        
        optionsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            optionsDropdown.classList.toggle('show');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            optionsDropdown.classList.remove('show');
        });

        // Add edit handler
        messageElement.querySelector('.edit-message').addEventListener('click', (e) => {
            e.stopPropagation();
            // TODO: Implement edit functionality
            console.log('Edit message:', messageData.id);
            optionsDropdown.classList.remove('show');
        });

        // Add delete handler
        messageElement.querySelector('.delete-message').addEventListener('click', (e) => {
            e.stopPropagation();
            // TODO: Implement delete functionality
            console.log('Delete message:', messageData.id);
            optionsDropdown.classList.remove('show');
        });
    }

    // Function to send a message
    async function sendMessage(content) {
        console.log('=== Send Message Started ===');
        
        try {
            // Validate inputs
            if (!content?.trim()) {
                throw new Error('Message content is empty');
            }
            if (!currentChatId) {
                throw new Error('No chat selected');
            }
            if (!currentStudioId) {
                throw new Error('No studio ID found');
            }

            // Get the user document ID
            const userDocId = localStorage.getItem('userDocId');
            if (!userDocId) {
                throw new Error('User document ID not found in localStorage');
            }

            // Get chat document to check permissions
            const chatDocRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId);
                
            const chatDoc = await chatDocRef.get();
            console.log('Chat document exists:', chatDoc.exists);
            
            if (!chatDoc.exists) {
                throw new Error('Chat not found');
            }

            const chatData = chatDoc.data();
            console.log('Chat data:', chatData);

            // Check if user can send messages
            if (chatData.CommunicationType === 'one-way' && 
                chatData.CreatedBy !== userDocId) {
                throw new Error('This is a one-way communication channel');
            }

            // Check if user is muted
            if (chatData.MutedMembers?.includes(userDocId)) {
                throw new Error('You have been muted in this conversation');
            }

            // Get user data for sender name
            const userDocRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Users')
                .doc(userDocId);
                
            const userDoc = await userDocRef.get();
            console.log('User document exists:', userDoc.exists);

            if (!userDoc.exists) {
                throw new Error('User document not found');
            }

            const userData = userDoc.data();
            console.log('User data:', userData);

            // Create message data
            const messageData = {
                Content: content.trim(),
                SenderId: userDocId, // Use userDocId instead of Firebase Auth UID
                SenderName: `${userData.FirstName} ${userData.LastName}`,
                Timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                ChatId: currentChatId
            };
            
            console.log('Preparing to save message:', messageData);

            // Save to Firestore
            const messageRef = await chatDocRef
                .collection('Messages')
                .add(messageData);
                
            console.log('Message saved with ID:', messageRef.id);

            // Clear input
            document.getElementById('messageInput').value = '';

            // Display message immediately with the correct ID
            displayMessage({
                ...messageData,
                id: messageRef.id,
                Timestamp: new Date() // Use current time for immediate display
            });

            // Scroll to bottom
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            return messageRef.id;

        } catch (error) {
            console.error('=== Error in sendMessage ===');
            console.error('Error:', error);
            console.error('Error stack:', error.stack);
            console.error('Current state:', {
                currentChatId,
                currentStudioId,
                userDocId: localStorage.getItem('userDocId')
            });
            throw error;
        }
    }

    // Add this debug function to test message sending
    async function testMessageSend() {
        try {
            console.log('Testing message send...');
            const testMessage = 'Test message ' + new Date().toISOString();
            const messageId = await sendMessage(testMessage);
            console.log('Test message sent successfully, ID:', messageId);
            return true;
        } catch (error) {
            console.error('Test message send failed:', error);
            return false;
        }
    }

    // Add button click handler with better error handling
    document.getElementById('sendMessageBtn').addEventListener('click', async () => {
        try {
            console.log('=== Send Button Click Handler ===');
            const messageInput = document.getElementById('messageInput');
            console.log('Message input value:', messageInput.value);
            console.log('Current chat ID:', currentChatId);
            console.log('Current studio ID:', currentStudioId);
            console.log('Current user:', firebase.auth().currentUser?.uid);
            
            if (messageInput.value.trim()) {
                console.log('Calling sendMessage...');
                await sendMessage(messageInput.value.trim());
            } else {
                console.log('Empty message, not sending');
            }
        } catch (error) {
            console.error('Error in click handler:', error);
        }
    });

    // Also update the keypress handler
    document.getElementById('messageInput').addEventListener('keypress', async (e) => {
        try {
            if (e.key === 'Enter' && !e.shiftKey) {
                console.log('=== Enter Key Handler ===');
                e.preventDefault();
                const messageInput = document.getElementById('messageInput');
                console.log('Message input value:', messageInput.value);
                console.log('Current chat ID:', currentChatId);
                console.log('Current studio ID:', currentStudioId);
                console.log('Current user:', firebase.auth().currentUser?.uid);
                
                if (messageInput.value.trim()) {
                    console.log('Calling sendMessage...');
                    await sendMessage(messageInput.value.trim());
                } else {
                    console.log('Empty message, not sending');
                }
            }
        } catch (error) {
            console.error('Error in keypress handler:', error);
        }
    });

    // Also add logging to the displayMessage function
    function displayMessage(messageData) {
        console.log('displayMessage called with data:', messageData);
        const messagesContainer = document.getElementById('messagesContainer');
        const messageElement = document.createElement('div');
        const currentUser = firebase.auth().currentUser;
        
        // Check if message is sent by current user
        const isSentByMe = messageData.SenderId === currentUser.uid;
        messageElement.className = `message ${isSentByMe ? 'sent' : ''}`;
        
        const timestamp = messageData.Timestamp?.toDate() || new Date();
        const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        messageElement.innerHTML = `
            <div class="message-content">
                <div class="message-main">
                    <div class="message-text">${messageData.Content}</div>
                    <div class="message-header">
                        <span class="message-author">${messageData.SenderName}</span>
                        <span class="message-time">${timeString}</span>
                    </div>
                </div>
                <div class="message-options">
                    <button class="message-options-btn" aria-label="Message options">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                    <div class="message-options-dropdown">
                        <div class="message-option edit-message">
                            <i class="fas fa-edit"></i>
                            Edit
                        </div>
                        <div class="message-option delete-message">
                            <i class="fas fa-trash"></i>
                            Delete
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        messagesContainer.appendChild(messageElement);
        console.log('Message displayed in UI');

        // Add click handler for options button
        const optionsBtn = messageElement.querySelector('.message-options-btn');
        const optionsDropdown = messageElement.querySelector('.message-options-dropdown');
        
        optionsBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            optionsDropdown.classList.toggle('show');
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', () => {
            optionsDropdown.classList.remove('show');
        });

        // Add edit handler
        messageElement.querySelector('.edit-message').addEventListener('click', (e) => {
            e.stopPropagation();
            // TODO: Implement edit functionality
            console.log('Edit message:', messageData.id);
            optionsDropdown.classList.remove('show');
        });

        // Add delete handler
        messageElement.querySelector('.delete-message').addEventListener('click', (e) => {
            e.stopPropagation();
            // TODO: Implement delete functionality
            console.log('Delete message:', messageData.id);
            optionsDropdown.classList.remove('show');
        });
    }
    </script>

    <script>
    // Add this at the start of your script
    firebase.auth().onAuthStateChanged((user) => {
        if (user) {
            console.log('Authenticated User ID:', user.uid);
            console.log('Current Studio ID:', currentStudioId);
            console.log('User Doc ID:', localStorage.getItem('userDocId'));
        }
    });
    </script>

    <!-- Add this script to handle the DM modal functionality -->
    <script>
    // Function to populate member list based on type and search
    async function populateDMMembers(type, searchQuery = '') {
        const memberList = document.querySelector('#createDMModal .member-list');
        memberList.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';

        try {
            let members = [];
            if (type === 'families') {
                members = await loadFamilies();
            } else if (type === 'instructors') {
                members = await loadInstructors();
            }

            // Filter members based on search query
            if (searchQuery) {
                const query = searchQuery.toLowerCase();
                members = members.filter(member => 
                    `${member.FirstName} ${member.LastName}`.toLowerCase().includes(query)
                );
            }

            memberList.innerHTML = '';
            members.forEach(member => {
                memberList.innerHTML += `
                    <div class="form-check">
                        <input class="form-check-input" type="radio" 
                               name="dmMember" 
                               value="${member.id}" 
                               id="dm_member_${member.id}">
                        <label class="form-check-label" for="dm_member_${member.id}">
                            ${member.FirstName} ${member.LastName}
                        </label>
                    </div>
                `;
            });

            if (members.length === 0) {
                memberList.innerHTML = '<div class="text-center">No members found</div>';
            }
        } catch (error) {
            console.error('Error loading members:', error);
            memberList.innerHTML = '<div class="text-danger">Error loading members</div>';
        }
    }

    // Event listener for member type selection
    document.getElementById('dmMemberType').addEventListener('change', function(e) {
        populateDMMembers(e.target.value);
    });

    // Event listener for search input
    document.getElementById('dmSearchInput').addEventListener('input', function(e) {
        const memberType = document.getElementById('dmMemberType').value;
        populateDMMembers(memberType, e.target.value);
    });

    // Initialize member list when modal is shown
    document.getElementById('createDMModal').addEventListener('show.bs.modal', function() {
        const initialType = document.getElementById('dmMemberType').value;
        populateDMMembers(initialType);
    });
    </script>

    <!-- Add this function to help debug -->
    <script>
    async function debugPermissions() {
        try {
            console.log('=== Debug Permissions ===');
            console.log('Auth UID:', firebase.auth().currentUser.uid);
            console.log('Studio ID:', currentStudioId);
            
            const userDoc = await firebase.firestore()
                .collection('Studios')
                .doc(currentStudioId)
                .collection('Users')
                .doc(localStorage.getItem('userDocId'))
                .get();
                
            console.log('User Doc:', userDoc.exists, userDoc.data());
            
            const chatDoc = await firebase.firestore()
                .collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc('4YkKeQt95df1lUBBGH61')
                .get();
                
            console.log('Chat Doc:', chatDoc.exists, chatDoc.data());
            console.log('=== End Debug ===');
        } catch (error) {
            console.error('Debug Error:', error);
        }
    }

    // Call this before trying to load messages
    await debugPermissions();
    </script>

    <!-- Add this at the start of your scripts -->
    <script>
    let currentUser = null;

    // Function to wait for auth state
    function waitForAuth() {
        return new Promise((resolve) => {
            const unsubscribe = firebase.auth().onAuthStateChanged((user) => {
                unsubscribe(); // Stop listening
                currentUser = user;
                resolve(user);
            });
        });
    }

    // Update the initialization
    document.addEventListener('DOMContentLoaded', async function() {
        try {
            // Wait for auth to initialize
            await waitForAuth();
            
            // Load communications only after auth is ready
            if (currentUser) {
                console.log('User authenticated, loading communications...');
                await loadAllCommunications();
            } else {
                console.error('No user logged in after auth initialization');
            }
        } catch (error) {
            console.error('Error during initialization:', error);
        }
    });
    </script>

    <!-- Add this modal HTML after your other modals -->
    <div class="modal fade" id="messageInfoModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Message Info</h5>
                    <div class="modal-header-buttons">
                        <button class="btn-close me-2" id="deleteConversationBtn" title="Delete Conversation">
                            <i class="fas fa-trash"></i>
                        </button>
                        <button type="button" class="btn-close" data-bs-dismiss="modal">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                </div>
                <div class="modal-body">
                    <h6 class="mb-3">Members</h6>
                    <div id="messageInfoMembers" class="members-list">
                        <!-- Members will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Add the delete confirmation modal -->
    <div class="modal fade" id="deleteConfirmModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Delete Conversation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete the conversation "<span id="deleteConversationName"></span>"?</p>
                    <p class="text-danger mb-0">This action cannot be undone.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-danger" id="confirmDeleteBtn">Delete</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this JavaScript -->
    <script>
    // Initialize tooltips
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
        return new bootstrap.Tooltip(tooltipTriggerEl);
    });

    // Update the info button click handler
    document.querySelector('.btn-icon').addEventListener('click', async function() {
        // Hide tooltip before showing modal
        const tooltip = bootstrap.Tooltip.getInstance(this);
        if (tooltip) {
            tooltip.hide();
        }
        
        if (!currentChatId) return;

        try {
            // Get the chat document
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .get();

            if (!chatDoc.exists) {
                console.error('Chat not found');
                return;
            }

            const chatData = chatDoc.data();
            const membersList = document.getElementById('messageInfoMembers');
            membersList.innerHTML = '<div class="text-center"><div class="spinner-border" role="status"></div></div>';

            // Show the modal
            const modal = new bootstrap.Modal(document.getElementById('messageInfoModal'));
            modal.show();

            // Fetch member details
            const memberPromises = chatData.Members.map(async (memberId) => {
                // Try to find in Users collection first
                let memberDoc = await db.collection('Studios')
                    .doc(currentStudioId)
                    .collection('Users')
                    .doc(memberId)
                    .get();

                if (!memberDoc.exists) {
                    // Try Families collection
                    memberDoc = await db.collection('Studios')
                        .doc(currentStudioId)
                        .collection('Families')
                        .doc(memberId)
                        .get();
                }

                if (!memberDoc.exists) {
                    // Try Instructors collection
                    memberDoc = await db.collection('Studios')
                        .doc(currentStudioId)
                        .collection('Instructors')
                        .doc(memberId)
                        .get();
                }

                if (memberDoc.exists) {
                    const data = memberDoc.data();
                    return {
                        id: memberId,
                        firstName: data.FirstName,
                        lastName: data.LastName,
                        role: data.Role || 'Member'
                    };
                }

                return null;
            });

            const members = (await Promise.all(memberPromises)).filter(member => member !== null);

            // Clear loading spinner and populate members
            membersList.innerHTML = '';
            members.forEach(member => {
                const initials = `${member.firstName[0]}${member.lastName[0]}`;
                const isBlinded = chatData.BlindedMembers?.includes(member.id);
                const isMuted = chatData.MutedMembers?.includes(member.id);
                
                membersList.innerHTML += `
                    <div class="member-item">
                        <div class="member-avatar">${initials}</div>
                        <div class="member-details flex-grow-1">
                            <div class="member-name">${member.firstName} ${member.lastName}</div>
                            <div class="member-role">${Array.isArray(member.role) ? member.role.join(', ') : member.role}</div>
                        </div>
                        <div class="member-controls">
                            <button class="btn btn-icon toggle-visibility" data-member-id="${member.id}" 
                                title="${isBlinded ? 'Enable visibility' : 'Disable visibility'}">
                                <i class="fas ${isBlinded ? 'fa-eye-slash' : 'fa-eye'}" style="color: ${isBlinded ? '#dc3545' : '#6c757d'}"></i>
                            </button>
                            <button class="btn btn-icon toggle-mute" data-member-id="${member.id}"
                                title="${isMuted ? 'Unmute member' : 'Mute member'}">
                                <i class="fas ${isMuted ? 'fa-volume-mute' : 'fa-volume-up'}" style="color: ${isMuted ? '#dc3545' : '#6c757d'}"></i>
                            </button>
                        </div>
                    </div>
                `;
            });

          
           
            // Add these after your existing message info modal code
            function attachMemberControlHandlers() {
                // Handle visibility toggles
                document.querySelectorAll('.toggle-visibility').forEach(button => {
                    button.addEventListener('click', async function() {
                        const memberId = this.dataset.memberId;
                        const icon = this.querySelector('i');
                        const isCurrentlyBlinded = icon.classList.contains('fa-eye-slash');
                        
                        try {
                            const chatRef = db.collection('Studios')
                                .doc(currentStudioId)
                                .collection('Communication')
                                .doc(currentChatId);
                            
                            const chatDoc = await chatRef.get();
                            const chatData = chatDoc.data();
                            let blindedMembers = chatData.BlindedMembers || [];
                            
                            if (isCurrentlyBlinded) {
                                // Remove from blinded members
                                blindedMembers = blindedMembers.filter(id => id !== memberId);
                                icon.classList.replace('fa-eye-slash', 'fa-eye');
                                icon.style.color = '#6c757d'; // Frost grey
                                this.title = 'Disable visibility';
                            } else {
                                // Add to blinded members
                                blindedMembers.push(memberId);
                                icon.classList.replace('fa-eye', 'fa-eye-slash');
                                icon.style.color = '#dc3545'; // Red
                                this.title = 'Enable visibility';
                            }
                            
                            await chatRef.update({ BlindedMembers: blindedMembers });
                        } catch (error) {
                            console.error('Error updating member visibility:', error);
                            alert('Failed to update member visibility');
                        }
                    });
                });

                // Handle mute toggles
                document.querySelectorAll('.toggle-mute').forEach(button => {
                    button.addEventListener('click', async function() {
                        const memberId = this.dataset.memberId;
                        const icon = this.querySelector('i');
                        const isCurrentlyMuted = icon.classList.contains('fa-volume-mute');
                        
                        try {
                            const chatRef = db.collection('Studios')
                                .doc(currentStudioId)
                                .collection('Communication')
                                .doc(currentChatId);
                            
                            const chatDoc = await chatRef.get();
                            const chatData = chatDoc.data();
                            let mutedMembers = chatData.MutedMembers || [];
                            
                            if (isCurrentlyMuted) {
                                // Remove from muted members
                                mutedMembers = mutedMembers.filter(id => id !== memberId);
                                icon.classList.replace('fa-volume-mute', 'fa-volume-up');
                                icon.style.color = '#6c757d'; // Frost grey
                                this.title = 'Mute member';
                            } else {
                                // Add to muted members
                                mutedMembers.push(memberId);
                                icon.classList.replace('fa-volume-up', 'fa-volume-mute');
                                icon.style.color = '#dc3545'; // Red
                                this.title = 'Unmute member';
                            }
                            
                            await chatRef.update({ MutedMembers: mutedMembers });
                        } catch (error) {
                            console.error('Error updating member mute status:', error);
                            alert('Failed to update member mute status');
                        }
                    });
                });
            }

            // Update your existing message info modal code to call this function
            // Add this line after populating the members list:
            attachMemberControlHandlers();

            // Update the loadMessages function to check for blinded members
            async function loadMessages(chatId) {
                const messagesContainer = document.getElementById('messagesContainer');
                messagesContainer.innerHTML = '';
                
                try {
                    const chatDoc = await db.collection('Studios')
                        .doc(currentStudioId)
                        .collection('Communication')
                        .doc(chatId)
                        .get();

                    if (!chatDoc.exists) {
                        throw new Error('Chat not found');
                    }

                    const chatData = chatDoc.data();
                    const currentUserId = firebase.auth().currentUser.uid;
                    
                    // Check if current user is blinded
                    if (chatData.BlindedMembers?.includes(currentUserId)) {
                        messagesContainer.innerHTML = '<div class="text-center text-muted p-4">You do not have permission to view these messages</div>';
                        return;
                    }

                    // Rest of your existing loadMessages code...
                } catch (error) {
                    console.error('Error in loadMessages:', error);
                    alert('Error loading messages: ' + error.message);
                }
            }

            // Update the sendMessage function to check for muted members
            async function sendMessage(content) {
                if (!currentChatId || !content.trim()) return;
                
                try {
                    const chatDoc = await db.collection('Studios')
                        .doc(currentStudioId)
                        .collection('Communication')
                        .doc(currentChatId)
                        .get();

                    const chatData = chatDoc.data();
                    const currentUserId = firebase.auth().currentUser.uid;
                    
                    // Check if user is muted
                    if (chatData.MutedMembers?.includes(currentUserId)) {
                        throw new Error('You have been muted in this conversation');
                    }

                    // Rest of your existing sendMessage code...
                } catch (error) {
                    console.error('Error sending message:', error);
                    alert(error.message);
                }
            }
        } catch (error) {
            console.error('Error loading message info:', error);
            alert('Error loading message information');
        }
    });
    </script>

    <script>
    // Add these functions outside the click handler
    async function loadMessages(chatId) {
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';
        
        try {
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(chatId)
                .get();

            if (!chatDoc.exists) {
                throw new Error('Chat not found');
            }

            const chatData = chatDoc.data();
            const currentUserId = firebase.auth().currentUser.uid;
            
            // Check if current user is blinded
            if (chatData.BlindedMembers?.includes(currentUserId)) {
                messagesContainer.innerHTML = '<div class="text-center text-muted p-4">You do not have permission to view these messages</div>';
                return;
            }

            // Rest of your existing loadMessages code...
        } catch (error) {
            console.error('Error in loadMessages:', error);
            alert('Error loading messages: ' + error.message);
        }
    }

    async function sendMessage(content) {
        if (!currentChatId || !content.trim()) return;
        
        try {
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .get();

            const chatData = chatDoc.data();
            const currentUserId = firebase.auth().currentUser.uid;
            
            // Check if user is muted
            if (chatData.MutedMembers?.includes(currentUserId)) {
                throw new Error('You have been muted in this conversation');
            }

            // Rest of your existing sendMessage code...
        } catch (error) {
            console.error('Error sending message:', error);
            alert(error.message);
        }
    }
    </script>

    <!-- Add this script to handle the delete functionality -->
    <script>
    // Add this to your existing message info modal click handler
    document.getElementById('deleteConversationBtn').addEventListener('click', async function() {
        if (!currentChatId) return;

        try {
            // Get the chat document to display the name
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .get();

            if (!chatDoc.exists) {
                throw new Error('Conversation not found');
            }

            const chatData = chatDoc.data();
            
            // Hide the message info modal
            const messageInfoModal = bootstrap.Modal.getInstance(document.getElementById('messageInfoModal'));
            messageInfoModal.hide();

            // Show delete confirmation modal
            document.getElementById('deleteConversationName').textContent = chatData.Name;
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));
            deleteModal.show();
        } catch (error) {
            console.error('Error preparing delete:', error);
            alert('Error preparing to delete conversation');
        }
    });

    // Handle the confirm delete button
    document.getElementById('confirmDeleteBtn').addEventListener('click', async function() {
        try {
            // Delete the communication document
            await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .delete();

            // Close the delete confirmation modal
            const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteConfirmModal'));
            deleteModal.hide();

            // Reset the chat area
            document.getElementById('currentChatName').textContent = 'Select a conversation';
            document.getElementById('memberCount').textContent = '';
            document.getElementById('messagesContainer').innerHTML = '';
            document.getElementById('messageInput').disabled = true;
            document.getElementById('sendMessageBtn').disabled = true;

            // Remove the conversation from the UI
            const groupElement = document.querySelector(`[data-group-id="${currentChatId}"]`);
            const dmElement = document.querySelector(`[data-dm-id="${currentChatId}"]`);
            if (groupElement) groupElement.remove();
            if (dmElement) dmElement.remove();

            // Reset current chat
            currentChatId = null;
            currentChatType = null;

            // Reload the conversations list
            await loadAllCommunications();

        } catch (error) {
            console.error('Error deleting conversation:', error);
            alert('Error deleting conversation');
        }
    });
    </script>

    <!-- Add these styles -->
    <style>
    .modal-header {
        position: relative;
        padding: 1rem;
    }

    .modal-header-buttons {
        position: absolute;
        top: 0.75rem;  /* Move both icons up */
        right: 1rem;
        display: flex;
        align-items: center;
        gap: 0.25rem;  /* Reduce gap between icons to move trash closer to X */
    }

    .modal-header .btn-close {
        padding: 0.5rem;
        background: none;
        border: none;
        opacity: 0.5;
        transition: opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 32px;
        width: 32px;
    }

    #deleteConversationBtn {
        background: none;
        border: none;
        padding: 0 0.15rem 0 0;  /* Add slight padding to right to nudge icon */
        opacity: 0.5;
        transition: opacity 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        height: 32px;
        width: 32px;
    }

    #deleteConversationBtn i {
        font-size: 1rem;
        color: #6c757d;
        line-height: 1;  /* Reset line height */
    }
    </style>

    <!-- Add this helper function to check the chat state -->
    <script>
    function debugChatState() {
        console.log('=== Chat State Debug ===');
        console.log('Current Chat ID:', currentChatId);
        console.log('Current Chat Type:', currentChatType);
        console.log('Current Studio ID:', currentStudioId);
        console.log('User Doc ID:', localStorage.getItem('userDocId'));
        console.log('Authenticated User:', firebase.auth().currentUser?.uid);
        console.log('Message Input Enabled:', !document.getElementById('messageInput').disabled);
        console.log('Send Button Enabled:', !document.getElementById('sendMessageBtn').disabled);
    }

    // Call this when clicking on a chat
    document.querySelectorAll('.group-item, .dm-item').forEach(item => {
        item.addEventListener('click', () => {
            setTimeout(debugChatState, 1000); // Check state after chat opens
        });
    });
    </script>

    <!-- Add this helper function to test Firebase connection -->
    <script>
    async function testFirebaseConnection() {
        try {
            console.log('Testing Firebase connection...');
            const testRef = db.collection('Studios').doc(currentStudioId);
            const doc = await testRef.get();
            console.log('Firebase connection successful, studio exists:', doc.exists);
            return true;
        } catch (error) {
            console.error('Firebase connection error:', error);
            return false;
        }
    }

    // Call this when the page loads
    document.addEventListener('DOMContentLoaded', async () => {
        await testFirebaseConnection();
    });
    </script>

    <!-- Add this to test the entire flow -->
    <script>
    // Add this to your existing message info modal click handler
    document.getElementById('deleteConversationBtn').addEventListener('click', async function() {
        if (!currentChatId) return;

        try {
            // Get the chat document to display the name
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .get();

            if (!chatDoc.exists) {
                throw new Error('Conversation not found');
            }

            const chatData = chatDoc.data();
            
            // Hide the message info modal
            const messageInfoModal = bootstrap.Modal.getInstance(document.getElementById('messageInfoModal'));
            messageInfoModal.hide();

            // Show delete confirmation modal
            document.getElementById('deleteConversationName').textContent = chatData.Name;
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));
            deleteModal.show();
        } catch (error) {
            console.error('Error preparing delete:', error);
            alert('Error preparing to delete conversation');
        }
    });

    // Handle the confirm delete button
    document.getElementById('confirmDeleteBtn').addEventListener('click', async function() {
        try {
            // Delete the communication document
            await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .delete();

            // Close the delete confirmation modal
            const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteConfirmModal'));
            deleteModal.hide();

            // Reset the chat area
            document.getElementById('currentChatName').textContent = 'Select a conversation';
            document.getElementById('memberCount').textContent = '';
            document.getElementById('messagesContainer').innerHTML = '';
            document.getElementById('messageInput').disabled = true;
            document.getElementById('sendMessageBtn').disabled = true;

            // Remove the conversation from the UI
            const groupElement = document.querySelector(`[data-group-id="${currentChatId}"]`);
            const dmElement = document.querySelector(`[data-dm-id="${currentChatId}"]`);
            if (groupElement) groupElement.remove();
            if (dmElement) dmElement.remove();

            // Reset current chat
            currentChatId = null;
            currentChatType = null;

            // Reload the conversations list
            await loadAllCommunications();

        } catch (error) {
            console.error('Error deleting conversation:', error);
            alert('Error deleting conversation');
        }
    });

    // Add this to test the entire flow
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            console.log('=== Testing Communication Setup ===');
            
            // Test Firebase connection
            const connected = await testFirebaseConnection();
            console.log('Firebase connection:', connected ? 'SUCCESS' : 'FAILED');
            
            // Test auth state
            const user = firebase.auth().currentUser;
            console.log('Auth state:', user ? 'LOGGED IN' : 'NOT LOGGED IN');
            
            // Log important variables
            console.log('Important variables:', {
                currentStudioId,
                userDocId: localStorage.getItem('userDocId'),
                userId: user?.uid
            });
            
        } catch (error) {
            console.error('Setup test failed:', error);
        }
    });
    </script>

    <!-- Add this debug function -->
    <script>
    async function testFirestorePaths() {
        try {
            console.log('=== Testing Firestore Paths ===');
            
            // Test studio path
            const studioRef = db.collection('Studios').doc(currentStudioId);
            const studioDoc = await studioRef.get();
            console.log('Studio exists:', studioDoc.exists);
            
            // Test chat path
            if (currentChatId) {
                const chatRef = studioRef
                    .collection('Communication')
                    .doc(currentChatId);
                const chatDoc = await chatRef.get();
                console.log('Chat exists:', chatDoc.exists);
                
                // Test messages collection
                const messagesRef = chatRef.collection('Messages');
                const messagesSnapshot = await messagesRef.limit(1).get();
                console.log('Messages collection accessible:', !messagesSnapshot.empty);
            }
            
            // Test user path
            const userRef = studioRef
                .collection('Users')
                .doc(localStorage.getItem('userDocId'));
            const userDoc = await userRef.get();
            console.log('User exists:', userDoc.exists);
            
            return true;
        } catch (error) {
            console.error('Firestore paths test failed:', error);
            return false;
        }
    }

    // Call this when opening a chat
    document.querySelectorAll('.group-item, .dm-item').forEach(item => {
        item.addEventListener('click', async () => {
            await testFirestorePaths();
        });
    });
    </script>

    <!-- Add this test function -->
    <script>
    async function testMessagePath() {
        try {
            console.log('=== Testing Message Path ===');
            const path = `Studios/${currentStudioId}/Communication/${currentChatId}/Messages`;
            console.log('Testing path:', path);
            
            const ref = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .collection('Messages');
                
            const test = await ref.limit(1).get();
            console.log('Collection exists and is accessible:', !test.empty);
            console.log('Collection path:', ref.path);
            return true;
        } catch (error) {
            console.error('Path test failed:', error);
            return false;
        }
    }

   
    // Update the sendMessage function to be more explicit about the return value
    async function sendMessage(content) {
        console.log('=== Send Message Started ===');
        console.log('Content:', content);
        console.log('Current Chat ID:', currentChatId);
        console.log('Current Studio ID:', currentStudioId);
        
        try {
            // Validate inputs
            if (!content?.trim()) {
                throw new Error('Message content is empty');
            }
            if (!currentChatId) {
                throw new Error('No chat selected');
            }
            if (!currentStudioId) {
                throw new Error('No studio ID found');
            }

            const currentUser = firebase.auth().currentUser;
            if (!currentUser) {
                throw new Error('No authenticated user');
            }

            // Get chat document to check permissions
            const chatDocRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId);
                
            const chatDoc = await chatDocRef.get();
            console.log('Chat document exists:', chatDoc.exists);
            
            if (!chatDoc.exists) {
                throw new Error('Chat not found');
            }

            const chatData = chatDoc.data();
            console.log('Chat data:', chatData);

            // Get user data for sender name
            const userDocRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Users')
                .doc(localStorage.getItem('userDocId'));
                
            const userDoc = await userDocRef.get();
            console.log('User document exists:', userDoc.exists);

            if (!userDoc.exists) {
                throw new Error('User document not found');
            }

            const userData = userDoc.data();
            console.log('User data:', userData);

            // Create message data
            const messageData = {
                Content: content.trim(),
                SenderId: currentUser.uid,
                SenderName: `${userData.FirstName} ${userData.LastName}`,
                Timestamp: firebase.firestore.FieldValue.serverTimestamp()
            };
            
            console.log('Preparing to save message:', messageData);

            // Save to Firestore
            const messagesRef = chatDocRef.collection('Messages');
            console.log('Saving message to collection:', messagesRef.path);
            
            const messageRef = await messagesRef.add(messageData);
            console.log('Message saved with ID:', messageRef.id);

            // Clear input
            document.getElementById('messageInput').value = '';

            // Display message immediately
            displayMessage({
                ...messageData,
                Timestamp: new Date() // Use current time for immediate display
            });

            // Scroll to bottom
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.scrollTop = messagesContainer.scrollHeight;

            return messageRef.id;

        } catch (error) {
            console.error('=== Error in sendMessage ===');
            console.error('Error:', error);
            console.error('Error stack:', error.stack);
            console.error('Current state:', {
                currentChatId,
                currentStudioId,
                userDocId: localStorage.getItem('userDocId'),
                userId: firebase.auth().currentUser?.uid
            });
            throw error;
        }
    }
    </script>

    <!-- Add the edit message modal -->
    <div class="modal fade" id="editMessageModal" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Edit Message</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <textarea id="editMessageContent" class="form-control" rows="4"></textarea>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="saveEditBtn">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <script>
    // Function to edit a message
    async function editMessage(messageId, newContent) {
        try {
            console.log('=== Edit Message Started ===');
            console.log('Parameters:', { messageId, newContent, currentChatId, currentStudioId });

            if (!currentChatId || !messageId || !newContent?.trim()) {
                throw new Error('Invalid parameters for editing message');
            }

            const messageRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .collection('Messages')
                .doc(messageId);

            console.log('Fetching message document...');
            const messageDoc = await messageRef.get();
            console.log('Message exists:', messageDoc.exists);
            
            if (!messageDoc.exists) {
                console.error('Message document not found at path:', messageRef.path);
                throw new Error('Message not found');
            }

            const messageData = messageDoc.data();
            const currentUser = firebase.auth().currentUser;

            console.log('Message data:', {
                messageData,
                currentUserId: currentUser.uid,
                isMatch: messageData.SenderId === currentUser.uid
            });

            // Check if the current user is the message sender
            if (messageData.SenderId !== currentUser.uid) {
                throw new Error('You can only edit your own messages');
            }

            // Update the message
            console.log('Updating message...');
            await messageRef.update({
                Content: newContent,
                EditedAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('Message updated successfully');

            // Update the message in the UI
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                const messageText = messageElement.querySelector('.message-text');
                messageText.textContent = newContent;
                
                // Add edited indicator if not already present
                if (!messageElement.querySelector('.edited-indicator')) {
                    const timeElement = messageElement.querySelector('.message-time');
                    timeElement.insertAdjacentHTML('beforeend', ' <span class="edited-indicator">(edited)</span>');
                }
                console.log('UI updated successfully');
            } else {
                console.warn('Message element not found in UI');
            }

        } catch (error) {
            console.error('=== Error in editMessage ===');
            console.error('Error:', error);
            console.error('Error stack:', error.stack);
            console.error('Current state:', {
                currentChatId,
                currentStudioId,
                userDocId: localStorage.getItem('userDocId'),
                userId: firebase.auth().currentUser?.uid
            });
            alert(error.message);
        }
    }

    // Function to delete a message
    async function deleteMessage(messageId) {
        try {
            if (!currentChatId || !messageId) {
                throw new Error('Invalid parameters for deleting message');
            }

            const messageRef = db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .collection('Messages')
                .doc(messageId);

            const messageDoc = await messageRef.get();
            if (!messageDoc.exists) {
                throw new Error('Message not found');
            }

            const messageData = messageDoc.data();
            const currentUser = firebase.auth().currentUser;

            // Check if the current user is the message sender
            if (messageData.SenderId !== currentUser.uid) {
                throw new Error('You can only delete your own messages');
            }

            // Delete the message
            await messageRef.delete();

            // Remove the message from the UI
            const messageElement = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageElement) {
                messageElement.remove();
            }

        } catch (error) {
            console.error('Error deleting message:', error);
            alert(error.message);
        }
    }

    // Update the displayMessage function to include message ID and edit/delete handlers
    function displayMessage(messageData) {
        console.log('displayMessage called with data:', messageData);
        const messagesContainer = document.getElementById('messagesContainer');
        const messageElement = document.createElement('div');
        const currentUser = firebase.auth().currentUser;
        
        // Check if message is sent by current user
        const isSentByMe = messageData.SenderId === currentUser.uid;
        messageElement.className = `message ${isSentByMe ? 'sent' : ''}`;
        
        // Get the correct message ID (it might be in .id or .Id)
        const messageId = messageData.id || messageData.Id;
        messageElement.setAttribute('data-message-id', messageId);
        
        const timestamp = messageData.Timestamp?.toDate() || new Date();
        const timeString = timestamp.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        
        messageElement.innerHTML = `
            <div class="message-content">
                <div class="message-main">
                    <div class="message-text">${messageData.Content}</div>
                    <div class="message-header">
                        <span class="message-author">${messageData.SenderName}</span>
                        <span class="message-time">
                            ${timeString}
                            ${messageData.EditedAt ? '<span class="edited-indicator">(edited)</span>' : ''}
                        </span>
                    </div>
                </div>
                ${isSentByMe ? `
                    <div class="message-options">
                        <button class="message-options-btn" aria-label="Message options">
                            <i class="fas fa-ellipsis-v"></i>
                        </button>
                        <div class="message-options-dropdown">
                            <div class="message-option edit-message">
                                <i class="fas fa-edit"></i>
                                Edit
                            </div>
                            <div class="message-option delete-message">
                                <i class="fas fa-trash"></i>
                                Delete
                            </div>
                        </div>
                    </div>
                ` : ''}
            </div>
        `;
        
        messagesContainer.appendChild(messageElement);

        // Only add options handlers if the message is sent by the current user
        if (isSentByMe) {
            const optionsBtn = messageElement.querySelector('.message-options-btn');
            const optionsDropdown = messageElement.querySelector('.message-options-dropdown');
            
            optionsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                optionsDropdown.classList.toggle('show');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', () => {
                optionsDropdown.classList.remove('show');
            });

            // Add edit handler
            messageElement.querySelector('.edit-message').addEventListener('click', async (e) => {
                e.stopPropagation();
                optionsDropdown.classList.remove('show');
                
                // Show edit modal
                const editModal = new bootstrap.Modal(document.getElementById('editMessageModal'));
                const editMessageContent = document.getElementById('editMessageContent');
                editMessageContent.value = messageData.Content;
                
                // Store the message ID for the save handler
                editMessageContent.setAttribute('data-editing-message-id', messageId);
                
                editModal.show();
            });

            // Add delete handler
            messageElement.querySelector('.delete-message').addEventListener('click', async (e) => {
                e.stopPropagation();
                optionsDropdown.classList.remove('show');
                
                if (confirm('Are you sure you want to delete this message?')) {
                    await deleteMessage(messageId);
                }
            });
        }

        // Scroll to bottom after adding new message
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }

    // Add save edit button handler
    document.getElementById('saveEditBtn').addEventListener('click', async function() {
        const editMessageContent = document.getElementById('editMessageContent');
        const messageId = editMessageContent.getAttribute('data-editing-message-id');
        const newContent = editMessageContent.value;

        // Close the modal
        const editModal = bootstrap.Modal.getInstance(document.getElementById('editMessageModal'));
        editModal.hide();

        // Edit the message
        await editMessage(messageId, newContent);
    });
    </script>

    <style>
    .edited-indicator {
        font-size: 0.8em;
        color: #d4d6dd;
        margin-left: 0.3em;
    }

    #editMessageContent {
        resize: none;
    }
    </style>

    <!-- Add this new function to get the display name for a DM -->
    <script>
    async function getDMDisplayName(dmData) {
        try {
            // Get the current user's document ID
            const currentUserDocId = localStorage.getItem('userDocId');
            if (!currentUserDocId) throw new Error('User document ID not found');
            
            // Find the other member in the conversation (not the current user)
            const otherMemberId = dmData.Members.find(id => id !== currentUserDocId);
            if (!otherMemberId) return 'Unknown User';
            
            // Try to find the user in different collections
            let memberDoc;
            
            // Try Users collection first
            memberDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Users')
                .doc(otherMemberId)
                .get();
                
            if (!memberDoc.exists) {
                // Try Families collection
                memberDoc = await db.collection('Studios')
                    .doc(currentStudioId)
                    .collection('Families')
                    .doc(otherMemberId)
                    .get();
            }
            
            if (!memberDoc.exists) {
                // Try Instructors collection
                memberDoc = await db.collection('Studios')
                    .doc(currentStudioId)
                    .collection('Instructors')
                    .doc(otherMemberId)
                    .get();
            }
            
            if (memberDoc.exists) {
                const data = memberDoc.data();
                return `${data.FirstName} ${data.LastName}`;
            }
            
            return 'Unknown User';
        } catch (error) {
            console.error('Error getting DM display name:', error);
            return 'Unknown User';
        }
    }
    </script>

    <!-- Add this event listener for the send button -->
    <script>
    // Add this to your existing message info modal click handler
    document.getElementById('deleteConversationBtn').addEventListener('click', async function() {
        if (!currentChatId) return;

        try {
            // Get the chat document to display the name
            const chatDoc = await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .get();

            if (!chatDoc.exists) {
                throw new Error('Conversation not found');
            }

            const chatData = chatDoc.data();
            
            // Hide the message info modal
            const messageInfoModal = bootstrap.Modal.getInstance(document.getElementById('messageInfoModal'));
            messageInfoModal.hide();

            // Show delete confirmation modal
            document.getElementById('deleteConversationName').textContent = chatData.Name;
            const deleteModal = new bootstrap.Modal(document.getElementById('deleteConfirmModal'));
            deleteModal.show();
        } catch (error) {
            console.error('Error preparing delete:', error);
            alert('Error preparing to delete conversation');
        }
    });

    // Handle the confirm delete button
    document.getElementById('confirmDeleteBtn').addEventListener('click', async function() {
        try {
            // Delete the communication document
            await db.collection('Studios')
                .doc(currentStudioId)
                .collection('Communication')
                .doc(currentChatId)
                .delete();

            // Close the delete confirmation modal
            const deleteModal = bootstrap.Modal.getInstance(document.getElementById('deleteConfirmModal'));
            deleteModal.hide();

            // Reset the chat area
            document.getElementById('currentChatName').textContent = 'Select a conversation';
            document.getElementById('memberCount').textContent = '';
            document.getElementById('messagesContainer').innerHTML = '';
            document.getElementById('messageInput').disabled = true;
            document.getElementById('sendMessageBtn').disabled = true;

            // Remove the conversation from the UI
            const groupElement = document.querySelector(`[data-group-id="${currentChatId}"]`);
            const dmElement = document.querySelector(`[data-dm-id="${currentChatId}"]`);
            if (groupElement) groupElement.remove();
            if (dmElement) dmElement.remove();

            // Reset current chat
            currentChatId = null;
            currentChatType = null;

            // Reload the conversations list
            await loadAllCommunications();

        } catch (error) {
            console.error('Error deleting conversation:', error);
            alert('Error deleting conversation');
        }
    });

    // Add this to test the entire flow
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            console.log('=== Testing Communication Setup ===');
            
            // Test Firebase connection
            const connected = await testFirebaseConnection();
            console.log('Firebase connection:', connected ? 'SUCCESS' : 'FAILED');
            
            // Test auth state
            const user = firebase.auth().currentUser;
            console.log('Auth state:', user ? 'LOGGED IN' : 'NOT LOGGED IN');
            
            // Log important variables
            console.log('Important variables:', {
                currentStudioId,
                userDocId: localStorage.getItem('userDocId'),
                userId: user?.uid
            });
            
        } catch (error) {
            console.error('Setup test failed:', error);
        }
    });

   
    </script>
</body>
</html>