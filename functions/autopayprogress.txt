const { onSchedule } = require("firebase-functions/v2/scheduler");
const { onRequest } = require("firebase-functions/v2/https");
const admin = require("firebase-admin");
const express = require("express");
const cors = require("cors");
const axios = require("axios"); // Make sure axios is installed

// Initialize Firebase Admin if not already initialized
if (!admin.apps.length) {
  admin.initializeApp();
}

// Create Express app for HTTP endpoint
const app = express();

// CORS configuration
app.use(cors({
  origin: [
    "https://studiosync-af73d.web.app",
    "https://studiosync-af73d.firebaseapp.com", 
    "https://studiosyncdance.com",
    "http://localhost:5000"
  ],
  methods: ["POST", "OPTIONS"],
  allowedHeaders: ["Content-Type", "Authorization"],
}));

/**
 * Process a payment using the same endpoint as student registration
 */
async function processPayment(paymentData) {
  try {
    console.log('üîÑ Processing payment with external service:', {
      studioId: paymentData.studioId,
      familyId: paymentData.familyId,
      amount: paymentData.amount,
      customerId: paymentData.customerId ? paymentData.customerId.substring(0, 4) + "..." + paymentData.customerId.substring(paymentData.customerId.length - 4) : undefined
    });
    
    // Get studio and family data
    console.log(`üîÑ Fetching studio data for ${paymentData.studioId}`);
    const studioDoc = await admin.firestore().collection('Studios').doc(paymentData.studioId).get();
    if (!studioDoc.exists) {
      console.error(`‚ùå Studio not found: ${paymentData.studioId}`);
      throw new Error(`Studio not found: ${paymentData.studioId}`);
    }
    const studioData = studioDoc.data();
    console.log(`‚úÖ Found studio: ${studioData.StudioName || paymentData.studioId}`);
    
    console.log(`üîÑ Fetching family data for ${paymentData.familyId}`);
    const familyDoc = await admin.firestore().collection(`Studios/${paymentData.studioId}/Families`).doc(paymentData.familyId).get();
    if (!familyDoc.exists) {
      console.error(`‚ùå Family not found: ${paymentData.familyId}`);
      throw new Error(`Family not found: ${paymentData.familyId}`);
    }
    const familyData = familyDoc.data();
    console.log(`‚úÖ Found family: ${familyData.LastName || paymentData.familyId}`);
    
    // Format the request data for the payment processing endpoint
    const paymentRequest = {
      url: process.env.PAYMENT_PROCESSOR_URL || "https://processpayments-22djwxzgmq-uc.a.run.app/process-payment",
      data: {
        studioId: paymentData.studioId,
        customerId: paymentData.customerId,
        payment: {
          amount: paymentData.amount,
          description: paymentData.description || `Auto payment for ${familyData.LastName} family`,
          reference: `autopay-${Date.now()}-${familyData.LastName}-${paymentData.familyId.substring(0, 8)}`
        },
        paymentType: "existingCustomer",
        card: {
          use_saved_method: true
        },
        transactionId: `autopay-${Date.now()}-${paymentData.familyId.substring(0, 8)}`,
        test_mode: true  // Set to true for testing with Payarc test API
      }
    };
    
    console.log('üîÑ Sending payment request to payment processor:', {
      url: paymentRequest.url,
      data: {
        ...paymentRequest.data,
        customerId: '****' // Mask sensitive data in logs
      }
    });
    
    // Call the payment processing endpoint
    console.log(`üîÑ Making API call to payment processor...`);
    const response = await axios.post(
      paymentRequest.url,
      { data: paymentRequest.data },
      {
        headers: {
          'Content-Type': 'application/json'
        }
      }
    );
    
    console.log(`‚úÖ Received response from payment processor with status: ${response.status}`);
    console.log('üîÑ Payment processor response:', {
      success: response.data.success,
      amount: response.data.amount,
      chargeId: response.data.chargeId,
      status: response.data.status,
      isPartialPayment: response.data.isPartialPayment
    });
    
    if (response.data.success) {
      // Payment was successful or partially successful
      console.log(`‚úÖ Payment was processed successfully by payment processor`);
      
      // Check if this was a partial payment
      const isPartialPayment = response.data.isPartialPayment || false;
      const actualAmount = response.data.amount || paymentData.amount;
      const requestedAmount = response.data.requestedAmount || paymentData.amount;
      
      if (isPartialPayment) {
        console.log(`‚ö†Ô∏è PARTIAL PAYMENT DETECTED: Requested $${requestedAmount.toFixed(2)}, Approved $${actualAmount.toFixed(2)}`);
        console.log(`‚ö†Ô∏è Difference: $${(requestedAmount - actualAmount).toFixed(2)}`);
      } else {
        console.log(`‚úÖ Full payment processed: $${actualAmount.toFixed(2)}`);
      }
      
      // Create a batch for all updates
      console.log(`üîÑ Creating Firestore batch for database updates...`);
      const batch = admin.firestore().batch();
      
      // Create payment record in family's payments subcollection
      console.log(`üîÑ Creating payment record in family's payments subcollection...`);
      const familyPaymentRef = admin.firestore()
        .collection(`Studios/${paymentData.studioId}/Families/${paymentData.familyId}/Payments`)
        .doc();
      
      // Create payment record in studio's payments subcollection
      console.log(`üîÑ Creating payment record in studio's payments subcollection...`);
      const studioPaymentRef = admin.firestore()
        .collection(`Studios/${paymentData.studioId}/Payments`)
        .doc();
      
      console.log(`üîÑ Payment document IDs: Family=${familyPaymentRef.id}, Studio=${studioPaymentRef.id}`);
      
      // Verify studio collection exists
      console.log(`üîÑ Verifying studio payments collection exists...`);
      const studioPaymentsCollection = admin.firestore()
        .collection(`Studios/${paymentData.studioId}/Payments`);
      
      try {
        const collectionSnapshot = await studioPaymentsCollection.limit(1).get();
        console.log(`‚úÖ Studio payments collection exists: ${collectionSnapshot.empty ? 'Empty collection' : 'Has documents'}`);
      } catch (error) {
        console.error(`‚ùå Error accessing studio payments collection: ${error.message}`);
      }
      
      // Prepare line items
      console.log(`üîÑ Preparing payment line items...`);
      const lineItems = [
        {
          Amount: response.data.subtotal || paymentData.amount,
          Description: "Payment Subtotal",
          Type: "Subtotal",
          StudentId: null
        }
      ];
      
      console.log(`üîÑ Added subtotal line item: $${lineItems[0].Amount.toFixed(2)}`);
      
      // Add surcharge line item if applicable
      if (response.data.surchargeAmount && response.data.surchargeAmount > 0) {
        console.log(`üîÑ Adding surcharge line item: $${response.data.surchargeAmount.toFixed(2)}`);
        lineItems.push({
          Amount: response.data.surchargeAmount,
          Description: "Processing Fee",
          Type: "ProcessingFee",
          StudentId: null
        });
      }
      
      // Determine payment method details
      console.log(`üîÑ Determining payment method details...`);
      const paymentMethodDetails = {
        Type: "Credit Card",
        LastFour: familyData.PaymentMethod?.LastFour || "****",
        CardType: familyData.PaymentMethod?.CardType || "Card"
      };
      
      console.log(`üîÑ Payment method: ${paymentMethodDetails.Type}, LastFour: ${paymentMethodDetails.LastFour}`);
      
      // Determine payment status
      const paymentStatus = isPartialPayment ? "Partial Payment" : "Paid";
      console.log(`üîÑ Setting payment status to: ${paymentStatus}`);
      
      // Create the payment document
      console.log(`üîÑ Creating payment document...`);
      const paymentDoc = {
        Amount: parseFloat(actualAmount.toFixed(2)),
        Subtotal: parseFloat(response.data.subtotal || (actualAmount - (response.data.surchargeAmount || 0)).toFixed(2)),
        ProcessingFee: parseFloat(response.data.surchargeAmount || 0).toFixed(2),
        CreatedAt: admin.firestore.FieldValue.serverTimestamp(),
        Description: paymentData.description || `Payment from ${familyData.FirstName} ${familyData.LastName}`,
        FamilyId: paymentData.familyId,
        FamilyName: `${familyData.FirstName} ${familyData.LastName}`,
        PayarcChargeId: response.data.chargeId || `test_${Date.now()}`,
        PaymentDate: admin.firestore.FieldValue.serverTimestamp(),
        PaymentMethod: paymentMethodDetails,
        Status: paymentStatus,
        Type: "Payment",
        RequestedAmount: requestedAmount,
        IsPartialPayment: isPartialPayment,
        UpdatedBalance: 0,
        LineItems: lineItems
      };
      
      console.log(`üîÑ Payment document prepared:`, {
        Amount: paymentDoc.Amount,
        Subtotal: paymentDoc.Subtotal,
        ProcessingFee: paymentDoc.ProcessingFee,
        Status: paymentDoc.Status,
        IsPartialPayment: paymentDoc.IsPartialPayment,
        FamilyId: paymentDoc.FamilyId,
        FamilyName: paymentDoc.FamilyName
      });
      
      // Set both payment documents
      console.log(`üîÑ Setting payment documents in batch...`);
      try {
        batch.set(familyPaymentRef, paymentDoc);
        console.log(`‚úÖ Added family payment document to batch`);
        
        batch.set(studioPaymentRef, paymentDoc);
        console.log(`‚úÖ Added studio payment document to batch`);
        
        // Update family balance - only reduce by the actual amount paid
        const currentBalance = familyData.Balance || 0;
        const newBalance = Math.max(0, currentBalance - actualAmount);
        
        // Use the family document reference we already have
        const familyRef = admin.firestore()
          .collection(`Studios/${paymentData.studioId}/Families`)
          .doc(paymentData.familyId);
        
        batch.update(familyRef, {
          Balance: newBalance,
          LastPayment: {
            Amount: actualAmount,
            Date: new Date().toISOString(),
            Method: 'Card',
            IsPartialPayment: isPartialPayment
          },
          UpdatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
        console.log(`‚úÖ Added family balance update to batch`);
        
        // First update family-level charges
        for (const charge of paymentData.chargeIds) {
          const familyChargeRef = admin.firestore()
            .collection(`Studios/${paymentData.studioId}/Families/${paymentData.familyId}/Charges`)
            .doc(charge);
            
          const updateData = {
            Status: 'Paid',
            AmountPaid: paymentData.amount,
            PaymentDate: admin.firestore.FieldValue.serverTimestamp(),
            PaymentId: familyPaymentRef.id,
            UpdatedAt: admin.firestore.FieldValue.serverTimestamp()
          };
          
          batch.update(familyChargeRef, updateData);
        }

        // After successful payment, get unpaid charges and filter by family in memory
        const studioChargesSnapshot = await admin.firestore()
          .collection(`Studios/${paymentData.studioId}/Charges`)
          .where('Status', '==', 'Unpaid')  // This simple where clause doesn't need an index
          .get();

        if (!studioChargesSnapshot.empty) {
          // Filter charges for this family
          const unpaidCharges = studioChargesSnapshot.docs
            .filter(doc => doc.data().FamilyId === paymentData.familyId)
            // Sort by CreatedAt in memory
            .sort((a, b) => b.data().CreatedAt.toDate() - a.data().CreatedAt.toDate());

          let remainingPaymentAmount = actualAmount;
          
          for (const studioChargeDoc of unpaidCharges) {
            const studioChargeData = studioChargeDoc.data();
            const chargeAmount = studioChargeData.Amount;
            
            if (remainingPaymentAmount <= 0) break;
            
            let amountToApply = Math.min(remainingPaymentAmount, chargeAmount);
            remainingPaymentAmount -= amountToApply;
            
            const updateData = {
              AmountPaid: amountToApply,
              PaymentDate: admin.firestore.FieldValue.serverTimestamp(),
              PaymentId: familyPaymentRef.id,
              UpdatedAt: admin.firestore.FieldValue.serverTimestamp()
            };
            
            // If full amount was paid, mark as Paid, otherwise Partial Payment
            if (amountToApply >= chargeAmount) {
              updateData.Status = 'Paid';
            } else {
              updateData.Status = 'Partial Payment';
            }
            
            batch.update(studioChargeDoc.ref, updateData);
            console.log(`‚úÖ Updated studio charge ${studioChargeDoc.id}: ${updateData.Status} - Amount: $${amountToApply}`);
          }
        }
        
        // Commit all the updates
        console.log(`üîÑ Committing batch updates...`);
        await batch.commit();
        
        // Verify documents were created
        console.log(`üîÑ Verifying documents were created...`);
        const familyDoc = await familyPaymentRef.get();
        const studioDoc = await studioPaymentRef.get();
        
        console.log(`Document creation status:
        - Family Payment: ${familyDoc.exists ? '‚úÖ Created' : '‚ùå Not Created'}
        - Studio Payment: ${studioDoc.exists ? '‚úÖ Created' : '‚ùå Not Created'}`);
        
        if (!studioDoc.exists) {
          console.error(`‚ùå Studio payment document was not created. Document ID: ${studioPaymentRef.id}`);
          console.error(`Collection path: Studios/${paymentData.studioId}/Payments`);
        }
        
        console.log(`‚úÖ Payment records created with IDs: Family=${familyPaymentRef.id}, Studio=${studioPaymentRef.id}`);
        
        return {
          success: true,
          paymentId: familyPaymentRef.id,
          chargeId: response.data.chargeId,
          amount: actualAmount,
          subtotal: response.data.subtotal,
          surchargeAmount: response.data.surchargeAmount,
          isPartialPayment: isPartialPayment,
          status: paymentStatus
        };
      } catch (error) {
        console.error(`‚ùå Error in batch operation: ${error.message}`);
        console.error(`Error details:`, error);
        throw error;
      }
    } else {
      console.error('Payment processing failed:', response.data.error);
      return {
        success: false,
        error: response.data.error || 'Payment processing failed'
      };
    }
    
  } catch (error) {
    console.error('Error processing payment:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Add this helper function
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Process auto payments for all studios or a specific studio
 */
async function processAutoPayments(studioId = null) {
  console.log(`Starting auto payment processing${studioId ? ` for studio ${studioId}` : ' for all studios'}`);
  
  try {
    // Get studios to process
    let studiosQuery = admin.firestore().collection('Studios');
    if (studioId) {
      studiosQuery = studiosQuery.where(admin.firestore.FieldPath.documentId(), '==', studioId);
    }
    
    const studiosSnapshot = await studiosQuery.get();
    
    if (studiosSnapshot.empty) {
      console.log(`No studios found${studioId ? ` with ID ${studioId}` : ''}`);
      return { success: false, error: 'No studios found' };
    }
    
    let totalProcessed = 0;
    let totalSuccessful = 0;
    let totalFailed = 0;
    const results = [];
    
    // Process each studio
    for (const studioDoc of studiosSnapshot.docs) {
      const currentStudioId = studioDoc.id;
      console.log(`Processing auto payments for studio: ${currentStudioId}`);
      
      // Get families on auto-pay with unpaid charges
      const familiesSnapshot = await admin.firestore()
        .collection(`Studios/${currentStudioId}/Families`)
        .where('IsOnAutoPay', '==', true)
        .get();
      
      console.log(`Found ${familiesSnapshot.size} families on auto-pay for studio ${currentStudioId}`);
      
      // Process each family
      for (const familyDoc of familiesSnapshot.docs) {
        const familyId = familyDoc.id;
        const familyData = familyDoc.data();
        
        // Skip if no payment method
        if (!familyData.PayarcCustomerId) {
          console.log(`Family ${familyId} is on auto-pay but has no payment method, skipping`);
          results.push({
            familyId,
            success: false,
            error: 'No payment method on file'
          });
          totalFailed++;
          continue;
        }
        
        // Get unpaid charges
        const chargesSnapshot = await admin.firestore()
          .collection(`Studios/${currentStudioId}/Families/${familyId}/Charges`)
          .where('Status', '==', 'Unpaid')
          .get();
        
        if (chargesSnapshot.empty) {
          console.log(`No unpaid charges for family ${familyId}, skipping`);
          continue;
        }
        
        // Calculate total amount to charge
        let totalAmount = 0;
        const chargesToUpdate = [];
        
        chargesSnapshot.forEach(chargeDoc => {
          const chargeData = chargeDoc.data();
          totalAmount += chargeData.Amount || 0;
          chargesToUpdate.push({
            id: chargeDoc.id,
            data: chargeData
          });
        });
        
        console.log(`Found ${chargesSnapshot.size} unpaid charges for family ${familyId}`);
        console.log(`Total amount to charge for family ${familyId}: $${totalAmount.toFixed(2)}`);
        
        if (totalAmount <= 0) {
          console.log(`No amount to charge for family ${familyId}, skipping`);
          continue;
        }
        
        totalProcessed++;
        
        // Add a random delay between payment attempts (2-5 seconds)
        await sleep(2000 + Math.random() * 3000);
        
        // Process payment
        try {
          console.log(`Processing payment for family ${familyId}, amount: $${totalAmount.toFixed(2)}`);
          
          // Create payment data object for processPayment function
          const paymentData = {
            studioId: currentStudioId,
            familyId: familyId,
            amount: totalAmount,
            description: `Auto payment for ${familyData.LastName} family`,
            paymentMethod: 'Card',
            customerId: familyData.PayarcCustomerId,
            chargeIds: chargesToUpdate.map(charge => charge.id)
          };
          
          // Call the processPayment function
          const paymentResult = await processPayment(paymentData);
          
          if (paymentResult.success) {
            console.log(`Payment successful for family ${familyId}`);
            totalSuccessful++;
            results.push({
              familyId,
              success: true,
              amount: totalAmount,
              paymentId: paymentResult.paymentId
            });
          } else {
            console.error(`Payment failed for family ${familyId}: ${paymentResult.error}`);
            totalFailed++;
            results.push({
              familyId,
              success: false,
              error: paymentResult.error
            });
          }
        } catch (error) {
          console.error(`Error processing payment for family ${familyId}:`, error);
          totalFailed++;
          results.push({
            familyId,
            success: false,
            error: error.message
          });
        }
      }
    }
    
    return {
      success: true,
      processed: totalProcessed,
      successful: totalSuccessful,
      failed: totalFailed,
      results: results
    };
  } catch (error) {
    console.error('Error processing auto payments:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// HTTP endpoint for processing auto payments
app.post('/', async (req, res) => {
  try {
    console.log("üïí Auto payments HTTP endpoint triggered");
    console.log("==========================================");
    
    // Set CORS headers explicitly
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'POST, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Content-Type, Authorization');
    
    const { studioId } = req.body;
    
    if (!studioId) {
      console.log("‚ùå Error: studioId is required");
      return res.status(400).json({ error: "studioId is required" });
    }
    
    // Get current date and log time in different timezones
    const today = new Date();
    const dayOfMonth = today.getDate();
    
    // Log times in different timezones
    const estTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/New_York' }));
    const cstTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Chicago' }));
    const mstTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Denver' }));
    const pstTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }));
    
    console.log(`\n‚è∞ EXECUTION START TIME (Day ${dayOfMonth} of month):
    EST: ${estTime.toLocaleString()}
    CST: ${cstTime.toLocaleString()}
    MST: ${mstTime.toLocaleString()}
    PST: ${pstTime.toLocaleString()}`);
    
    console.log("\nüìä EXECUTION SUMMARY:");
    console.log("==========================================");
    
    // Get studio data
    console.log(`\nüîç PROCESSING STUDIO: ${studioId}`);
    console.log("------------------------------------------");
    
    const studioDoc = await admin.firestore().collection("Studios").doc(studioId).get();
    
    if (!studioDoc.exists) {
      console.log(`‚ùå Studio not found: ${studioId}`);
      return res.status(404).json({ error: "Studio not found" });
    }
    
    const studioData = studioDoc.data();
    
    // Get PaymentProcessing settings
    const settingsDoc = await admin
      .firestore()
      .collection(`Studios/${studioId}/PaymentProcessing`)
      .doc("Settings")
      .get();

    const settingsData = settingsDoc.exists ? settingsDoc.data() : null;
    const autoPayBillingDay = settingsData?.General?.AutoPayBillingDay;
    const autoPaymentsEnabled = settingsData?.General?.AutoPaymentsEnabled;
    
    console.log(`Settings Status:
    - Settings Document Exists: ${settingsDoc.exists ? '‚úÖ' : '‚ùå'}
    - AutoPayments Enabled: ${autoPaymentsEnabled ? '‚úÖ' : '‚ùå'}
    - AutoPay Billing Day: ${autoPayBillingDay || 'Not Set'}`);
    
    // Get all families for this studio
    const familiesSnapshot = await studioDoc.ref.collection("Families").get();
    
    console.log(`\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Found ${familiesSnapshot.docs.length} families for studio ${studioId}`);
    
    let totalFamiliesProcessed = 0;
    let totalPaymentsProcessed = 0;
    let totalAmountProcessed = 0;
    
    // Process each family
    for (const familyDoc of familiesSnapshot.docs) {
      const familyId = familyDoc.id;
      const familyData = familyDoc.data();
      
      try {
        console.log(`\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Processing family: ${familyData.LastName || familyId}`);
        
        // Skip if no payment method
        if (!familyData.PayarcCustomerId) {
          console.log(`‚ùå No payment method on file - skipping`);
          continue;
        }
        
        // Get unpaid charges from both family and studio level
        const familyChargesSnapshot = await admin.firestore()
          .collection(`Studios/${studioId}/Families/${familyId}/Charges`)
          .where('Status', '==', 'Unpaid')
          .get();
          
        const studioChargesSnapshot = await admin.firestore()
          .collection(`Studios/${studioId}/Charges`)
          .where('FamilyId', '==', familyId)
          .where('Status', '==', 'Unpaid')
          .get();
        
        if (familyChargesSnapshot.empty && studioChargesSnapshot.empty) {
          console.log(`‚ÑπÔ∏è No unpaid charges - skipping`);
          continue;
        }
        
        // Calculate total amount
        let totalAmount = 0;
        const chargesToUpdate = [];
        
        // Process family-level charges
        familyChargesSnapshot.forEach(chargeDoc => {
          const chargeData = chargeDoc.data();
          totalAmount += chargeData.Amount || 0;
          chargesToUpdate.push({
            id: chargeDoc.id,
            data: chargeData
          });
        });
        
        console.log(`üí∞ Found ${familyChargesSnapshot.size} unpaid charges totaling $${totalAmount.toFixed(2)}`);
        
        if (totalAmount <= 0) {
          console.log(`‚ÑπÔ∏è No amount to charge - skipping`);
          continue;
        }
        
        // Process payment
        const paymentData = {
          studioId,
          familyId,
          amount: totalAmount,
          description: `Auto payment for ${familyData.LastName} family`,
          paymentMethod: 'Card',
          customerId: familyData.PayarcCustomerId,
          chargeIds: chargesToUpdate.map(charge => charge.id)
        };
        
        console.log(`üí≥ Processing payment of $${totalAmount.toFixed(2)}`);
        
        const paymentResult = await processPayment(paymentData);
        
        if (paymentResult.success) {
          console.log(`‚úÖ Payment successful`);
          
          // Create payment records in both family and studio collections
          const familyPaymentRef = admin.firestore()
            .collection(`Studios/${studioId}/Families/${familyId}/Payments`)
            .doc();
            
          const studioPaymentRef = admin.firestore()
            .collection(`Studios/${studioId}/Payments`)
            .doc();
            
            // Create the payment document
            const paymentDoc = {
              Amount: paymentResult.amount,
              Subtotal: paymentResult.subtotal,
              ProcessingFee: paymentResult.surchargeAmount,
              CreatedAt: admin.firestore.FieldValue.serverTimestamp(),
              Description: `Auto payment for ${familyData.LastName} family`,
              FamilyId: familyId,
              FamilyName: `${familyData.FirstName} ${familyData.LastName}`,
              PayarcChargeId: paymentResult.chargeId,
              PaymentDate: admin.firestore.FieldValue.serverTimestamp(),
              PaymentMethod: {
                Type: "Credit Card",
                LastFour: familyData.PaymentMethod?.LastFour || "****",
                CardType: familyData.PaymentMethod?.CardType || "Card"
              },
              Status: paymentResult.isPartialPayment ? "Partial Payment" : "Paid",
              Type: "Payment",
              RequestedAmount: paymentResult.requestedAmount,
              IsPartialPayment: paymentResult.isPartialPayment,
              UpdatedBalance: 0,
              LineItems: [
                {
                  Amount: paymentResult.subtotal,
                  Description: "Payment Subtotal",
                  Type: "Subtotal",
                  StudentId: null
                }
              ]
            };

            // Add surcharge line item if applicable
            if (paymentResult.surchargeAmount > 0) {
              paymentDoc.LineItems.push({
                Amount: paymentResult.surchargeAmount,
                Description: "Processing Fee",
                Type: "ProcessingFee",
                StudentId: null
              });
            }

            // Create a batch for atomic updates
            const batch = admin.firestore().batch();
            
            // Set both payment documents
            batch.set(familyPaymentRef, paymentDoc);
            batch.set(studioPaymentRef, paymentDoc);
            
            // First update family-level charges
            for (const charge of chargesToUpdate) {
              const familyChargeRef = admin.firestore()
                .collection(`Studios/${studioId}/Families/${familyId}/Charges`)
                .doc(charge.id);
                
              const updateData = {
                Status: 'Paid',
                AmountPaid: charge.data.Amount,
                PaymentDate: admin.firestore.FieldValue.serverTimestamp(),
                PaymentId: familyPaymentRef.id,
                UpdatedAt: admin.firestore.FieldValue.serverTimestamp()
              };
              
              batch.update(familyChargeRef, updateData);
            }

            // After successful payment, get unpaid charges and filter by family in memory
            const studioChargesSnapshot = await admin.firestore()
              .collection(`Studios/${studioId}/Charges`)
              .where('Status', '==', 'Unpaid')  // This simple where clause doesn't need an index
              .get();

            if (!studioChargesSnapshot.empty) {
              // Filter charges for this family
              const unpaidCharges = studioChargesSnapshot.docs
                .filter(doc => doc.data().FamilyId === familyId)
                // Sort by CreatedAt in memory
                .sort((a, b) => b.data().CreatedAt.toDate() - a.data().CreatedAt.toDate());

              let remainingPaymentAmount = paymentResult.amount;
              
              for (const studioChargeDoc of unpaidCharges) {
                const studioChargeData = studioChargeDoc.data();
                const chargeAmount = studioChargeData.Amount;
                
                if (remainingPaymentAmount <= 0) break;
                
                let amountToApply = Math.min(remainingPaymentAmount, chargeAmount);
                remainingPaymentAmount -= amountToApply;
                
                const updateData = {
                  AmountPaid: amountToApply,
                  PaymentDate: admin.firestore.FieldValue.serverTimestamp(),
                  PaymentId: familyPaymentRef.id,
                  UpdatedAt: admin.firestore.FieldValue.serverTimestamp()
                };
                
                // If full amount was paid, mark as Paid, otherwise Partial Payment
                if (amountToApply >= chargeAmount) {
                  updateData.Status = 'Paid';
                } else {
                  updateData.Status = 'Partial Payment';
                }
                
                batch.update(studioChargeDoc.ref, updateData);
                console.log(`‚úÖ Updated studio charge ${studioChargeDoc.id}: ${updateData.Status} - Amount: $${amountToApply}`);
              }
            }
            
            // Commit all updates
            await batch.commit();
            
            console.log(`‚úÖ Payment records created with IDs: Family=${familyPaymentRef.id}, Studio=${studioPaymentRef.id}`);
            
            totalFamiliesProcessed++;
            totalPaymentsProcessed++;
            totalAmountProcessed += totalAmount;
        } else {
          console.log(`‚ùå Payment failed: ${paymentResult.error}`);
        }
      } catch (error) {
        console.error(`‚ùå Error processing family ${familyId}:`, error);
      }
    }
    
    // Log final summary
    console.log("\n==========================================");
    console.log("üèÅ EXECUTION COMPLETE");
    console.log("==========================================");
    console.log(`Final Summary:
    - Total Families Processed: ${totalFamiliesProcessed}
    - Total Payments Processed: ${totalPaymentsProcessed}
    - Total Amount Processed: $${totalAmountProcessed.toFixed(2)}`);
    
    return res.status(200).json({
      success: true,
      familiesProcessed: totalFamiliesProcessed,
      paymentsProcessed: totalPaymentsProcessed,
      amountProcessed: totalAmountProcessed
    });
    
  } catch (error) {
    console.error("‚ùå Error in auto payment HTTP endpoint:", error);
    return res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Scheduled function for processing auto payments
exports.processAutoPay = onSchedule({
  schedule: "30 5 * * *", // Run at 5:30 AM every day
  timeZone: "America/New_York",
  retryCount: 3,
  region: "us-central1",
  memory: "1GiB",
  timeoutSeconds: 540 // 9 minutes timeout
}, async (event) => {
  console.log("üïí Auto payments scheduled function triggered");
  console.log("==========================================");
  
  try {
    // Get current date and log time in different timezones
    const today = new Date();
    const dayOfMonth = today.getDate();
    
    // Log times in different timezones
    const estTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/New_York' }));
    const cstTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Chicago' }));
    const mstTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Denver' }));
    const pstTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Los_Angeles' }));
    
    console.log(`\n‚è∞ EXECUTION START TIME (Day ${dayOfMonth} of month):
    EST: ${estTime.toLocaleString()}
    CST: ${cstTime.toLocaleString()}
    MST: ${mstTime.toLocaleString()}
    PST: ${pstTime.toLocaleString()}`);
    
    console.log("\nüìä EXECUTION SUMMARY:");
    console.log("==========================================");
    
    // Get all studios
    const studiosSnapshot = await admin.firestore().collection("Studios").get();
    console.log(`\nüè¢ Found ${studiosSnapshot.docs.length} studios to check for auto payments`);
    
    let studiosProcessed = 0;
    let totalFamiliesProcessed = 0;
    let totalPaymentsProcessed = 0;
    let totalAmountProcessed = 0;
    
    // Process each studio
    for (const studioDoc of studiosSnapshot.docs) {
      const studioId = studioDoc.id;
      const studioData = studioDoc.data();
      
      try {
        console.log(`\nüîç PROCESSING STUDIO: ${studioId}`);
        console.log("------------------------------------------");
        
        // Get PaymentProcessing settings
        const settingsDoc = await admin
          .firestore()
          .collection(`Studios/${studioId}/PaymentProcessing`)
          .doc("Settings")
          .get();

        const settingsData = settingsDoc.exists ? settingsDoc.data() : null;
        const autoPayBillingDay = settingsData?.General?.AutoPayBillingDay;
        const autoPaymentsEnabled = settingsData?.General?.AutoPaymentsEnabled;
        
        console.log(`Settings Status:
        - Settings Document Exists: ${settingsDoc.exists ? '‚úÖ' : '‚ùå'}
        - AutoPayments Enabled: ${autoPaymentsEnabled ? '‚úÖ' : '‚ùå'}
        - AutoPay Billing Day: ${autoPayBillingDay || 'Not Set'}`);
        
        // Check if studio has auto pay configured
        if (autoPayBillingDay === undefined || !autoPaymentsEnabled) {
          console.log(`‚ùå Skipping studio ${studioId} - AutoPay not configured or disabled`);
          continue;
        }

        // Check if today is the auto pay day
        const isTodayAutoPayDay = dayOfMonth === autoPayBillingDay;
        console.log(`\nüìÖ Day Check:
        - Current Day: ${dayOfMonth}
        - Studio's AutoPay Day: ${autoPayBillingDay}
        - Is Today AutoPay Day? ${isTodayAutoPayDay ? '‚úÖ YES' : '‚ùå NO'}`);
        
        if (!isTodayAutoPayDay) {
          console.log(`‚è≠Ô∏è Skipping studio ${studioId} - not their AutoPay day`);
          continue;
        }
        
        console.log(`\nüí≥ Processing payments for studio ${studioId}`);
        
        // Get families on auto-pay
        const familiesSnapshot = await admin.firestore()
          .collection(`Studios/${studioId}/Families`)
          .where('IsOnAutoPay', '==', true)
          .get();
        
        console.log(`\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Found ${familiesSnapshot.size} families on auto-pay`);
        
        let studioFamiliesProcessed = 0;
        let studioPaymentsProcessed = 0;
        let studioAmountProcessed = 0;
        
        // Process families in batches
        const batchSize = 5;
        const families = familiesSnapshot.docs;
        
        for (let i = 0; i < families.length; i += batchSize) {
          const batch = families.slice(i, i + batchSize);
          console.log(`\nüîÑ Processing batch ${i/batchSize + 1} of ${Math.ceil(families.length/batchSize)}`);
          
          // Process each family in the batch
          const batchResults = await Promise.all(batch.map(async (familyDoc) => {
            const familyId = familyDoc.id;
            const familyData = familyDoc.data();
            
            try {
              console.log(`\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Processing family: ${familyData.LastName || familyId}`);
              
              // Skip if no payment method
              if (!familyData.PayarcCustomerId) {
                console.log(`‚ùå No payment method on file - skipping`);
                return {
                  familyId,
                  success: false,
                  error: 'No payment method on file'
                };
              }
              
              // Get unpaid charges from both family and studio level
              const familyChargesSnapshot = await admin.firestore()
                .collection(`Studios/${studioId}/Families/${familyId}/Charges`)
                .where('Status', '==', 'Unpaid')
                .get();
                
              const studioChargesSnapshot = await admin.firestore()
                .collection(`Studios/${studioId}/Charges`)
                .where('FamilyId', '==', familyId)
                .where('Status', '==', 'Unpaid')
                .get();
              
              if (familyChargesSnapshot.empty && studioChargesSnapshot.empty) {
                console.log(`‚ÑπÔ∏è No unpaid charges - skipping`);
                return {
                  familyId,
                  success: true,
                  message: 'No unpaid charges'
                };
              }
              
              // Calculate total amount
              let totalAmount = 0;
              const chargesToUpdate = [];
              
              // Process family-level charges
              familyChargesSnapshot.forEach(chargeDoc => {
                const chargeData = chargeDoc.data();
                totalAmount += chargeData.Amount || 0;
                chargesToUpdate.push({
                  id: chargeDoc.id,
                  data: chargeData
                });
              });
              
              console.log(`üí∞ Found ${familyChargesSnapshot.size} unpaid charges totaling $${totalAmount.toFixed(2)}`);
              
              if (totalAmount <= 0) {
                console.log(`‚ÑπÔ∏è No amount to charge - skipping`);
                return {
                  familyId,
                  success: true,
                  message: 'No amount to charge'
                };
              }
              
              // Process payment
              const paymentData = {
                studioId,
                familyId,
                amount: totalAmount,
                description: `Auto payment for ${familyData.LastName} family`,
                paymentMethod: 'Card',
                customerId: familyData.PayarcCustomerId,
                chargeIds: chargesToUpdate.map(charge => charge.id)
              };
              
              console.log(`üí≥ Processing payment of $${totalAmount.toFixed(2)}`);
              
              const paymentResult = await processPayment(paymentData);
              
              if (paymentResult.success) {
                console.log(`‚úÖ Payment successful`);
                return {
                  familyId,
                  success: true,
                  amount: totalAmount,
                  paymentId: paymentResult.paymentId
                };
              } else {
                console.log(`‚ùå Payment failed: ${paymentResult.error}`);
                return {
                  familyId,
                  success: false,
                  error: paymentResult.error
                };
              }
            } catch (error) {
              console.error(`‚ùå Error processing family ${familyId}:`, error);
              return {
                familyId,
                success: false,
                error: error.message
              };
            }
          }));
          
          // Process batch results
          batchResults.forEach(result => {
            if (result.success) {
              studioFamiliesProcessed++;
              if (result.amount) {
                studioPaymentsProcessed++;
                studioAmountProcessed += result.amount;
              }
            }
          });
          
          // Add delay between batches
          if (i + batchSize < families.length) {
            await new Promise(resolve => setTimeout(resolve, 2000));
          }
        }
        
        // Update totals
        totalFamiliesProcessed += studioFamiliesProcessed;
        totalPaymentsProcessed += studioPaymentsProcessed;
        totalAmountProcessed += studioAmountProcessed;
        
        console.log(`\nüìä Studio ${studioId} Summary:
        - Families Processed: ${studioFamiliesProcessed}
        - Payments Processed: ${studioPaymentsProcessed}
        - Total Amount: $${studioAmountProcessed.toFixed(2)}`);
        
        studiosProcessed++;
      } catch (error) {
        console.error(`‚ùå Error processing studio ${studioId}:`, error);
      }
    }
    
    // Log final summary
    console.log("\n==========================================");
    console.log("üèÅ EXECUTION COMPLETE");
    console.log("==========================================");
    console.log(`Final Summary:
    - Studios Processed: ${studiosProcessed}
    - Total Families Processed: ${totalFamiliesProcessed}
    - Total Payments Processed: ${totalPaymentsProcessed}
    - Total Amount Processed: $${totalAmountProcessed.toFixed(2)}`);
    
    return {
      success: true,
      studiosProcessed,
      familiesProcessed: totalFamiliesProcessed,
      paymentsProcessed: totalPaymentsProcessed,
      amountProcessed: totalAmountProcessed
    };
    
  } catch (error) {
    console.error("‚ùå Error in auto payments processing:", error);
    throw error;
  }
});

// Export the HTTP endpoint
exports.processAutoPayHttp = onRequest({
  region: "us-central1",
  memory: "512MiB",
  cors: true,
  invoker: "public"
}, app);

// Also export the function for testing or manual triggering
exports.processAutoPayments = processAutoPayments;
